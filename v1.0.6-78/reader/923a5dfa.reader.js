(function(global) {

	var EPUBcfi = {};

	EPUBcfi.Parser = (function(){
		/*
		 * Generated by PEG.js 0.7.0.
		 *
		 * http://pegjs.majda.cz/
		 */

		function quote(s) {
			/*
			 * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
			 * string literal except for the closing quote character, backslash,
			 * carriage return, line separator, paragraph separator, and line feed.
			 * Any character may appear in the form of an escape sequence.
			 *
			 * For portability, we also escape escape all control and non-ASCII
			 * characters. Note that "\0" and "\v" escape sequences are not used
			 * because JSHint does not like the first and IE the second.
			 */
			return '"' + s
				.replace(/\\/g, '\\\\')  // backslash
				.replace(/"/g, '\\"')    // closing quote character
				.replace(/\x08/g, '\\b') // backspace
				.replace(/\t/g, '\\t')   // horizontal tab
				.replace(/\n/g, '\\n')   // line feed
				.replace(/\f/g, '\\f')   // form feed
				.replace(/\r/g, '\\r')   // carriage return
				.replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
				+ '"';
		}

		var result = {
			/*
			 * Parses the input with a generated parser. If the parsing is successfull,
			 * returns a value explicitly or implicitly specified by the grammar from
			 * which the parser was generated (see |PEG.buildParser|). If the parsing is
			 * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
			 */
			parse: function(input, startRule) {
				var parseFunctions = {
					"fragment": parse_fragment,
					"range": parse_range,
					"path": parse_path,
					"local_path": parse_local_path,
					"indexStep": parse_indexStep,
					"indirectionStep": parse_indirectionStep,
					"terminus": parse_terminus,
					"idAssertion": parse_idAssertion,
					"textLocationAssertion": parse_textLocationAssertion,
					"parameter": parse_parameter,
					"csv": parse_csv,
					"valueNoSpace": parse_valueNoSpace,
					"value": parse_value,
					"escapedSpecialChars": parse_escapedSpecialChars,
					"number": parse_number,
					"integer": parse_integer,
					"space": parse_space,
					"circumflex": parse_circumflex,
					"doubleQuote": parse_doubleQuote,
					"squareBracket": parse_squareBracket,
					"parentheses": parse_parentheses,
					"comma": parse_comma,
					"semicolon": parse_semicolon,
					"equal": parse_equal,
					"character": parse_character
				};

				if (startRule !== undefined) {
					if (parseFunctions[startRule] === undefined) {
						throw new Error("Invalid rule name: " + quote(startRule) + ".");
					}
				} else {
					startRule = "fragment";
				}

				var pos = 0;
				var reportFailures = 0;
				var rightmostFailuresPos = 0;
				var rightmostFailuresExpected = [];

				function padLeft(input, padding, length) {
					var result = input;

					var padLength = length - input.length;
					for (var i = 0; i < padLength; i++) {
						result = padding + result;
					}

					return result;
				}

				function escape(ch) {
					var charCode = ch.charCodeAt(0);
					var escapeChar;
					var length;

					if (charCode <= 0xFF) {
						escapeChar = 'x';
						length = 2;
					} else {
						escapeChar = 'u';
						length = 4;
					}

					return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
				}

				function matchFailed(failure) {
					if (pos < rightmostFailuresPos) {
						return;
					}

					if (pos > rightmostFailuresPos) {
						rightmostFailuresPos = pos;
						rightmostFailuresExpected = [];
					}

					rightmostFailuresExpected.push(failure);
				}

				function parse_fragment() {
					var result0, result1, result2;
					var pos0, pos1;

					pos0 = pos;
					pos1 = pos;
					if (input.substr(pos, 8) === "epubcfi(") {
						result0 = "epubcfi(";
						pos += 8;
					} else {
						result0 = null;
						if (reportFailures === 0) {
							matchFailed("\"epubcfi(\"");
						}
					}
					if (result0 !== null) {
						result1 = parse_range();
						if (result1 === null) {
							result1 = parse_path();
						}
						if (result1 !== null) {
							if (input.charCodeAt(pos) === 41) {
								result2 = ")";
								pos++;
							} else {
								result2 = null;
								if (reportFailures === 0) {
									matchFailed("\")\"");
								}
							}
							if (result2 !== null) {
								result0 = [result0, result1, result2];
							} else {
								result0 = null;
								pos = pos1;
							}
						} else {
							result0 = null;
							pos = pos1;
						}
					} else {
						result0 = null;
						pos = pos1;
					}
					if (result0 !== null) {
						result0 = (function(offset, fragmentVal) {

							return { type:"CFIAST", cfiString:fragmentVal };
						})(pos0, result0[1]);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_range() {
					var result0, result1, result2, result3, result4, result5;
					var pos0, pos1;

					pos0 = pos;
					pos1 = pos;
					result0 = parse_indexStep();
					if (result0 !== null) {
						result1 = parse_local_path();
						if (result1 !== null) {
							if (input.charCodeAt(pos) === 44) {
								result2 = ",";
								pos++;
							} else {
								result2 = null;
								if (reportFailures === 0) {
									matchFailed("\",\"");
								}
							}
							if (result2 !== null) {
								result3 = parse_local_path();
								if (result3 !== null) {
									if (input.charCodeAt(pos) === 44) {
										result4 = ",";
										pos++;
									} else {
										result4 = null;
										if (reportFailures === 0) {
											matchFailed("\",\"");
										}
									}
									if (result4 !== null) {
										result5 = parse_local_path();
										if (result5 !== null) {
											result0 = [result0, result1, result2, result3, result4, result5];
										} else {
											result0 = null;
											pos = pos1;
										}
									} else {
										result0 = null;
										pos = pos1;
									}
								} else {
									result0 = null;
									pos = pos1;
								}
							} else {
								result0 = null;
								pos = pos1;
							}
						} else {
							result0 = null;
							pos = pos1;
						}
					} else {
						result0 = null;
						pos = pos1;
					}
					if (result0 !== null) {
						result0 = (function(offset, stepVal, localPathVal, rangeLocalPath1Val, rangeLocalPath2Val) {

							return { type:"range", path:stepVal, localPath:localPathVal, range1:rangeLocalPath1Val, range2:rangeLocalPath2Val };
						})(pos0, result0[0], result0[1], result0[3], result0[5]);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_path() {
					var result0, result1;
					var pos0, pos1;

					pos0 = pos;
					pos1 = pos;
					result0 = parse_indexStep();
					if (result0 !== null) {
						result1 = parse_local_path();
						if (result1 !== null) {
							result0 = [result0, result1];
						} else {
							result0 = null;
							pos = pos1;
						}
					} else {
						result0 = null;
						pos = pos1;
					}
					if (result0 !== null) {
						result0 = (function(offset, stepVal, localPathVal) {

							return { type:"path", path:stepVal, localPath:localPathVal };
						})(pos0, result0[0], result0[1]);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_local_path() {
					var result0, result1;
					var pos0, pos1;

					pos0 = pos;
					pos1 = pos;
					result1 = parse_indexStep();
					if (result1 === null) {
						result1 = parse_indirectionStep();
					}
					if (result1 !== null) {
						result0 = [];
						while (result1 !== null) {
							result0.push(result1);
							result1 = parse_indexStep();
							if (result1 === null) {
								result1 = parse_indirectionStep();
							}
						}
					} else {
						result0 = null;
					}
					if (result0 !== null) {
						result1 = parse_terminus();
						result1 = result1 !== null ? result1 : "";
						if (result1 !== null) {
							result0 = [result0, result1];
						} else {
							result0 = null;
							pos = pos1;
						}
					} else {
						result0 = null;
						pos = pos1;
					}
					if (result0 !== null) {
						result0 = (function(offset, localPathStepVal, termStepVal) {

							return { steps:localPathStepVal, termStep:termStepVal };
						})(pos0, result0[0], result0[1]);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_indexStep() {
					var result0, result1, result2, result3, result4;
					var pos0, pos1, pos2;

					pos0 = pos;
					pos1 = pos;
					if (input.charCodeAt(pos) === 47) {
						result0 = "/";
						pos++;
					} else {
						result0 = null;
						if (reportFailures === 0) {
							matchFailed("\"/\"");
						}
					}
					if (result0 !== null) {
						result1 = parse_integer();
						if (result1 !== null) {
							pos2 = pos;
							if (input.charCodeAt(pos) === 91) {
								result2 = "[";
								pos++;
							} else {
								result2 = null;
								if (reportFailures === 0) {
									matchFailed("\"[\"");
								}
							}
							if (result2 !== null) {
								result3 = parse_idAssertion();
								if (result3 !== null) {
									if (input.charCodeAt(pos) === 93) {
										result4 = "]";
										pos++;
									} else {
										result4 = null;
										if (reportFailures === 0) {
											matchFailed("\"]\"");
										}
									}
									if (result4 !== null) {
										result2 = [result2, result3, result4];
									} else {
										result2 = null;
										pos = pos2;
									}
								} else {
									result2 = null;
									pos = pos2;
								}
							} else {
								result2 = null;
								pos = pos2;
							}
							result2 = result2 !== null ? result2 : "";
							if (result2 !== null) {
								result0 = [result0, result1, result2];
							} else {
								result0 = null;
								pos = pos1;
							}
						} else {
							result0 = null;
							pos = pos1;
						}
					} else {
						result0 = null;
						pos = pos1;
					}
					if (result0 !== null) {
						result0 = (function(offset, stepLengthVal, assertVal) {

							return { type:"indexStep", stepLength:stepLengthVal, idAssertion:assertVal[1] };
						})(pos0, result0[1], result0[2]);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_indirectionStep() {
					var result0, result1, result2, result3, result4;
					var pos0, pos1, pos2;

					pos0 = pos;
					pos1 = pos;
					if (input.substr(pos, 2) === "!/") {
						result0 = "!/";
						pos += 2;
					} else {
						result0 = null;
						if (reportFailures === 0) {
							matchFailed("\"!/\"");
						}
					}
					if (result0 !== null) {
						result1 = parse_integer();
						if (result1 !== null) {
							pos2 = pos;
							if (input.charCodeAt(pos) === 91) {
								result2 = "[";
								pos++;
							} else {
								result2 = null;
								if (reportFailures === 0) {
									matchFailed("\"[\"");
								}
							}
							if (result2 !== null) {
								result3 = parse_idAssertion();
								if (result3 !== null) {
									if (input.charCodeAt(pos) === 93) {
										result4 = "]";
										pos++;
									} else {
										result4 = null;
										if (reportFailures === 0) {
											matchFailed("\"]\"");
										}
									}
									if (result4 !== null) {
										result2 = [result2, result3, result4];
									} else {
										result2 = null;
										pos = pos2;
									}
								} else {
									result2 = null;
									pos = pos2;
								}
							} else {
								result2 = null;
								pos = pos2;
							}
							result2 = result2 !== null ? result2 : "";
							if (result2 !== null) {
								result0 = [result0, result1, result2];
							} else {
								result0 = null;
								pos = pos1;
							}
						} else {
							result0 = null;
							pos = pos1;
						}
					} else {
						result0 = null;
						pos = pos1;
					}
					if (result0 !== null) {
						result0 = (function(offset, stepLengthVal, assertVal) {

							return { type:"indirectionStep", stepLength:stepLengthVal, idAssertion:assertVal[1] };
						})(pos0, result0[1], result0[2]);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_terminus() {
					var result0, result1, result2, result3, result4;
					var pos0, pos1, pos2;

					pos0 = pos;
					pos1 = pos;
					if (input.charCodeAt(pos) === 58) {
						result0 = ":";
						pos++;
					} else {
						result0 = null;
						if (reportFailures === 0) {
							matchFailed("\":\"");
						}
					}
					if (result0 !== null) {
						result1 = parse_integer();
						if (result1 !== null) {
							pos2 = pos;
							if (input.charCodeAt(pos) === 91) {
								result2 = "[";
								pos++;
							} else {
								result2 = null;
								if (reportFailures === 0) {
									matchFailed("\"[\"");
								}
							}
							if (result2 !== null) {
								result3 = parse_textLocationAssertion();
								if (result3 !== null) {
									if (input.charCodeAt(pos) === 93) {
										result4 = "]";
										pos++;
									} else {
										result4 = null;
										if (reportFailures === 0) {
											matchFailed("\"]\"");
										}
									}
									if (result4 !== null) {
										result2 = [result2, result3, result4];
									} else {
										result2 = null;
										pos = pos2;
									}
								} else {
									result2 = null;
									pos = pos2;
								}
							} else {
								result2 = null;
								pos = pos2;
							}
							result2 = result2 !== null ? result2 : "";
							if (result2 !== null) {
								result0 = [result0, result1, result2];
							} else {
								result0 = null;
								pos = pos1;
							}
						} else {
							result0 = null;
							pos = pos1;
						}
					} else {
						result0 = null;
						pos = pos1;
					}
					if (result0 !== null) {
						result0 = (function(offset, textOffsetValue, textLocAssertVal) {

							return { type:"textTerminus", offsetValue:textOffsetValue, textAssertion:textLocAssertVal[1] };
						})(pos0, result0[1], result0[2]);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_idAssertion() {
					var result0;
					var pos0;

					pos0 = pos;
					result0 = parse_value();
					if (result0 !== null) {
						result0 = (function(offset, idVal) {

							return idVal;
						})(pos0, result0);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_textLocationAssertion() {
					var result0, result1;
					var pos0, pos1;

					pos0 = pos;
					pos1 = pos;
					result0 = parse_csv();
					result0 = result0 !== null ? result0 : "";
					if (result0 !== null) {
						result1 = parse_parameter();
						result1 = result1 !== null ? result1 : "";
						if (result1 !== null) {
							result0 = [result0, result1];
						} else {
							result0 = null;
							pos = pos1;
						}
					} else {
						result0 = null;
						pos = pos1;
					}
					if (result0 !== null) {
						result0 = (function(offset, csvVal, paramVal) {

							return { type:"textLocationAssertion", csv:csvVal, parameter:paramVal };
						})(pos0, result0[0], result0[1]);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_parameter() {
					var result0, result1, result2, result3;
					var pos0, pos1;

					pos0 = pos;
					pos1 = pos;
					if (input.charCodeAt(pos) === 59) {
						result0 = ";";
						pos++;
					} else {
						result0 = null;
						if (reportFailures === 0) {
							matchFailed("\";\"");
						}
					}
					if (result0 !== null) {
						result1 = parse_valueNoSpace();
						if (result1 !== null) {
							if (input.charCodeAt(pos) === 61) {
								result2 = "=";
								pos++;
							} else {
								result2 = null;
								if (reportFailures === 0) {
									matchFailed("\"=\"");
								}
							}
							if (result2 !== null) {
								result3 = parse_valueNoSpace();
								if (result3 !== null) {
									result0 = [result0, result1, result2, result3];
								} else {
									result0 = null;
									pos = pos1;
								}
							} else {
								result0 = null;
								pos = pos1;
							}
						} else {
							result0 = null;
							pos = pos1;
						}
					} else {
						result0 = null;
						pos = pos1;
					}
					if (result0 !== null) {
						result0 = (function(offset, paramLHSVal, paramRHSVal) {

							return { type:"parameter", LHSValue:paramLHSVal, RHSValue:paramRHSVal };
						})(pos0, result0[1], result0[3]);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_csv() {
					var result0, result1, result2;
					var pos0, pos1;

					pos0 = pos;
					pos1 = pos;
					result0 = parse_value();
					result0 = result0 !== null ? result0 : "";
					if (result0 !== null) {
						if (input.charCodeAt(pos) === 44) {
							result1 = ",";
							pos++;
						} else {
							result1 = null;
							if (reportFailures === 0) {
								matchFailed("\",\"");
							}
						}
						if (result1 !== null) {
							result2 = parse_value();
							result2 = result2 !== null ? result2 : "";
							if (result2 !== null) {
								result0 = [result0, result1, result2];
							} else {
								result0 = null;
								pos = pos1;
							}
						} else {
							result0 = null;
							pos = pos1;
						}
					} else {
						result0 = null;
						pos = pos1;
					}
					if (result0 !== null) {
						result0 = (function(offset, preAssertionVal, postAssertionVal) {

							return { type:"csv", preAssertion:preAssertionVal, postAssertion:postAssertionVal };
						})(pos0, result0[0], result0[2]);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_valueNoSpace() {
					var result0, result1;
					var pos0;

					pos0 = pos;
					result1 = parse_escapedSpecialChars();
					if (result1 === null) {
						result1 = parse_character();
					}
					if (result1 !== null) {
						result0 = [];
						while (result1 !== null) {
							result0.push(result1);
							result1 = parse_escapedSpecialChars();
							if (result1 === null) {
								result1 = parse_character();
							}
						}
					} else {
						result0 = null;
					}
					if (result0 !== null) {
						result0 = (function(offset, stringVal) {

							return stringVal.join('');
						})(pos0, result0);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_value() {
					var result0, result1;
					var pos0;

					pos0 = pos;
					result1 = parse_escapedSpecialChars();
					if (result1 === null) {
						result1 = parse_character();
						if (result1 === null) {
							result1 = parse_space();
						}
					}
					if (result1 !== null) {
						result0 = [];
						while (result1 !== null) {
							result0.push(result1);
							result1 = parse_escapedSpecialChars();
							if (result1 === null) {
								result1 = parse_character();
								if (result1 === null) {
									result1 = parse_space();
								}
							}
						}
					} else {
						result0 = null;
					}
					if (result0 !== null) {
						result0 = (function(offset, stringVal) {

							return stringVal.join('');
						})(pos0, result0);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_escapedSpecialChars() {
					var result0, result1;
					var pos0, pos1;

					pos0 = pos;
					pos1 = pos;
					result0 = parse_circumflex();
					if (result0 !== null) {
						result1 = parse_circumflex();
						if (result1 !== null) {
							result0 = [result0, result1];
						} else {
							result0 = null;
							pos = pos1;
						}
					} else {
						result0 = null;
						pos = pos1;
					}
					if (result0 === null) {
						pos1 = pos;
						result0 = parse_circumflex();
						if (result0 !== null) {
							result1 = parse_squareBracket();
							if (result1 !== null) {
								result0 = [result0, result1];
							} else {
								result0 = null;
								pos = pos1;
							}
						} else {
							result0 = null;
							pos = pos1;
						}
						if (result0 === null) {
							pos1 = pos;
							result0 = parse_circumflex();
							if (result0 !== null) {
								result1 = parse_parentheses();
								if (result1 !== null) {
									result0 = [result0, result1];
								} else {
									result0 = null;
									pos = pos1;
								}
							} else {
								result0 = null;
								pos = pos1;
							}
							if (result0 === null) {
								pos1 = pos;
								result0 = parse_circumflex();
								if (result0 !== null) {
									result1 = parse_comma();
									if (result1 !== null) {
										result0 = [result0, result1];
									} else {
										result0 = null;
										pos = pos1;
									}
								} else {
									result0 = null;
									pos = pos1;
								}
								if (result0 === null) {
									pos1 = pos;
									result0 = parse_circumflex();
									if (result0 !== null) {
										result1 = parse_semicolon();
										if (result1 !== null) {
											result0 = [result0, result1];
										} else {
											result0 = null;
											pos = pos1;
										}
									} else {
										result0 = null;
										pos = pos1;
									}
									if (result0 === null) {
										pos1 = pos;
										result0 = parse_circumflex();
										if (result0 !== null) {
											result1 = parse_equal();
											if (result1 !== null) {
												result0 = [result0, result1];
											} else {
												result0 = null;
												pos = pos1;
											}
										} else {
											result0 = null;
											pos = pos1;
										}
									}
								}
							}
						}
					}
					if (result0 !== null) {
						result0 = (function(offset, escSpecCharVal) {

							return escSpecCharVal[1];
						})(pos0, result0);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_number() {
					var result0, result1, result2, result3;
					var pos0, pos1, pos2;

					pos0 = pos;
					pos1 = pos;
					pos2 = pos;
					if (/^[1-9]/.test(input.charAt(pos))) {
						result0 = input.charAt(pos);
						pos++;
					} else {
						result0 = null;
						if (reportFailures === 0) {
							matchFailed("[1-9]");
						}
					}
					if (result0 !== null) {
						if (/^[0-9]/.test(input.charAt(pos))) {
							result2 = input.charAt(pos);
							pos++;
						} else {
							result2 = null;
							if (reportFailures === 0) {
								matchFailed("[0-9]");
							}
						}
						if (result2 !== null) {
							result1 = [];
							while (result2 !== null) {
								result1.push(result2);
								if (/^[0-9]/.test(input.charAt(pos))) {
									result2 = input.charAt(pos);
									pos++;
								} else {
									result2 = null;
									if (reportFailures === 0) {
										matchFailed("[0-9]");
									}
								}
							}
						} else {
							result1 = null;
						}
						if (result1 !== null) {
							result0 = [result0, result1];
						} else {
							result0 = null;
							pos = pos2;
						}
					} else {
						result0 = null;
						pos = pos2;
					}
					if (result0 !== null) {
						if (input.charCodeAt(pos) === 46) {
							result1 = ".";
							pos++;
						} else {
							result1 = null;
							if (reportFailures === 0) {
								matchFailed("\".\"");
							}
						}
						if (result1 !== null) {
							pos2 = pos;
							result2 = [];
							if (/^[0-9]/.test(input.charAt(pos))) {
								result3 = input.charAt(pos);
								pos++;
							} else {
								result3 = null;
								if (reportFailures === 0) {
									matchFailed("[0-9]");
								}
							}
							while (result3 !== null) {
								result2.push(result3);
								if (/^[0-9]/.test(input.charAt(pos))) {
									result3 = input.charAt(pos);
									pos++;
								} else {
									result3 = null;
									if (reportFailures === 0) {
										matchFailed("[0-9]");
									}
								}
							}
							if (result2 !== null) {
								if (/^[1-9]/.test(input.charAt(pos))) {
									result3 = input.charAt(pos);
									pos++;
								} else {
									result3 = null;
									if (reportFailures === 0) {
										matchFailed("[1-9]");
									}
								}
								if (result3 !== null) {
									result2 = [result2, result3];
								} else {
									result2 = null;
									pos = pos2;
								}
							} else {
								result2 = null;
								pos = pos2;
							}
							if (result2 !== null) {
								result0 = [result0, result1, result2];
							} else {
								result0 = null;
								pos = pos1;
							}
						} else {
							result0 = null;
							pos = pos1;
						}
					} else {
						result0 = null;
						pos = pos1;
					}
					if (result0 !== null) {
						result0 = (function(offset, intPartVal, fracPartVal) {

							return intPartVal.join('') + "." + fracPartVal.join('');
						})(pos0, result0[0], result0[2]);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_integer() {
					var result0, result1, result2;
					var pos0, pos1;

					pos0 = pos;
					if (input.charCodeAt(pos) === 48) {
						result0 = "0";
						pos++;
					} else {
						result0 = null;
						if (reportFailures === 0) {
							matchFailed("\"0\"");
						}
					}
					if (result0 === null) {
						pos1 = pos;
						if (/^[1-9]/.test(input.charAt(pos))) {
							result0 = input.charAt(pos);
							pos++;
						} else {
							result0 = null;
							if (reportFailures === 0) {
								matchFailed("[1-9]");
							}
						}
						if (result0 !== null) {
							result1 = [];
							if (/^[0-9]/.test(input.charAt(pos))) {
								result2 = input.charAt(pos);
								pos++;
							} else {
								result2 = null;
								if (reportFailures === 0) {
									matchFailed("[0-9]");
								}
							}
							while (result2 !== null) {
								result1.push(result2);
								if (/^[0-9]/.test(input.charAt(pos))) {
									result2 = input.charAt(pos);
									pos++;
								} else {
									result2 = null;
									if (reportFailures === 0) {
										matchFailed("[0-9]");
									}
								}
							}
							if (result1 !== null) {
								result0 = [result0, result1];
							} else {
								result0 = null;
								pos = pos1;
							}
						} else {
							result0 = null;
							pos = pos1;
						}
					}
					if (result0 !== null) {
						result0 = (function(offset, integerVal) {

							if (integerVal === "0") {
								return "0";
							}
							else {
								return integerVal[0].concat(integerVal[1].join(''));
							}
						})(pos0, result0);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_space() {
					var result0;
					var pos0;

					pos0 = pos;
					if (input.charCodeAt(pos) === 32) {
						result0 = " ";
						pos++;
					} else {
						result0 = null;
						if (reportFailures === 0) {
							matchFailed("\" \"");
						}
					}
					if (result0 !== null) {
						result0 = (function(offset) { return " "; })(pos0);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_circumflex() {
					var result0;
					var pos0;

					pos0 = pos;
					if (input.charCodeAt(pos) === 94) {
						result0 = "^";
						pos++;
					} else {
						result0 = null;
						if (reportFailures === 0) {
							matchFailed("\"^\"");
						}
					}
					if (result0 !== null) {
						result0 = (function(offset) { return "^"; })(pos0);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_doubleQuote() {
					var result0;
					var pos0;

					pos0 = pos;
					if (input.charCodeAt(pos) === 34) {
						result0 = "\"";
						pos++;
					} else {
						result0 = null;
						if (reportFailures === 0) {
							matchFailed("\"\\\"\"");
						}
					}
					if (result0 !== null) {
						result0 = (function(offset) { return '"'; })(pos0);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_squareBracket() {
					var result0;
					var pos0;

					pos0 = pos;
					if (input.charCodeAt(pos) === 91) {
						result0 = "[";
						pos++;
					} else {
						result0 = null;
						if (reportFailures === 0) {
							matchFailed("\"[\"");
						}
					}
					if (result0 === null) {
						if (input.charCodeAt(pos) === 93) {
							result0 = "]";
							pos++;
						} else {
							result0 = null;
							if (reportFailures === 0) {
								matchFailed("\"]\"");
							}
						}
					}
					if (result0 !== null) {
						result0 = (function(offset, bracketVal) { return bracketVal; })(pos0, result0);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_parentheses() {
					var result0;
					var pos0;

					pos0 = pos;
					if (input.charCodeAt(pos) === 40) {
						result0 = "(";
						pos++;
					} else {
						result0 = null;
						if (reportFailures === 0) {
							matchFailed("\"(\"");
						}
					}
					if (result0 === null) {
						if (input.charCodeAt(pos) === 41) {
							result0 = ")";
							pos++;
						} else {
							result0 = null;
							if (reportFailures === 0) {
								matchFailed("\")\"");
							}
						}
					}
					if (result0 !== null) {
						result0 = (function(offset, paraVal) { return paraVal; })(pos0, result0);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_comma() {
					var result0;
					var pos0;

					pos0 = pos;
					if (input.charCodeAt(pos) === 44) {
						result0 = ",";
						pos++;
					} else {
						result0 = null;
						if (reportFailures === 0) {
							matchFailed("\",\"");
						}
					}
					if (result0 !== null) {
						result0 = (function(offset) { return ","; })(pos0);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_semicolon() {
					var result0;
					var pos0;

					pos0 = pos;
					if (input.charCodeAt(pos) === 59) {
						result0 = ";";
						pos++;
					} else {
						result0 = null;
						if (reportFailures === 0) {
							matchFailed("\";\"");
						}
					}
					if (result0 !== null) {
						result0 = (function(offset) { return ";"; })(pos0);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_equal() {
					var result0;
					var pos0;

					pos0 = pos;
					if (input.charCodeAt(pos) === 61) {
						result0 = "=";
						pos++;
					} else {
						result0 = null;
						if (reportFailures === 0) {
							matchFailed("\"=\"");
						}
					}
					if (result0 !== null) {
						result0 = (function(offset) { return "="; })(pos0);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}

				function parse_character() {
					var result0;
					var pos0;

					pos0 = pos;
					if (/^[a-z]/.test(input.charAt(pos))) {
						result0 = input.charAt(pos);
						pos++;
					} else {
						result0 = null;
						if (reportFailures === 0) {
							matchFailed("[a-z]");
						}
					}
					if (result0 === null) {
						if (/^[A-Z]/.test(input.charAt(pos))) {
							result0 = input.charAt(pos);
							pos++;
						} else {
							result0 = null;
							if (reportFailures === 0) {
								matchFailed("[A-Z]");
							}
						}
						if (result0 === null) {
							if (/^[0-9]/.test(input.charAt(pos))) {
								result0 = input.charAt(pos);
								pos++;
							} else {
								result0 = null;
								if (reportFailures === 0) {
									matchFailed("[0-9]");
								}
							}
							if (result0 === null) {
								if (input.charCodeAt(pos) === 45) {
									result0 = "-";
									pos++;
								} else {
									result0 = null;
									if (reportFailures === 0) {
										matchFailed("\"-\"");
									}
								}
								if (result0 === null) {
									if (input.charCodeAt(pos) === 95) {
										result0 = "_";
										pos++;
									} else {
										result0 = null;
										if (reportFailures === 0) {
											matchFailed("\"_\"");
										}
									}
									if (result0 === null) {
										if (input.charCodeAt(pos) === 46) {
											result0 = ".";
											pos++;
										} else {
											result0 = null;
											if (reportFailures === 0) {
												matchFailed("\".\"");
											}
										}
									}
								}
							}
						}
					}
					if (result0 !== null) {
						result0 = (function(offset, charVal) { return charVal; })(pos0, result0);
					}
					if (result0 === null) {
						pos = pos0;
					}
					return result0;
				}


				function cleanupExpected(expected) {
					expected.sort();

					var lastExpected = null;
					var cleanExpected = [];
					for (var i = 0; i < expected.length; i++) {
						if (expected[i] !== lastExpected) {
							cleanExpected.push(expected[i]);
							lastExpected = expected[i];
						}
					}
					return cleanExpected;
				}

				function computeErrorPosition() {
					/*
					 * The first idea was to use |String.split| to break the input up to the
					 * error position along newlines and derive the line and column from
					 * there. However IE's |split| implementation is so broken that it was
					 * enough to prevent it.
					 */

					var line = 1;
					var column = 1;
					var seenCR = false;

					for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
						var ch = input.charAt(i);
						if (ch === "\n") {
							if (!seenCR) { line++; }
							column = 1;
							seenCR = false;
						} else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
							line++;
							column = 1;
							seenCR = true;
						} else {
							column++;
							seenCR = false;
						}
					}

					return { line: line, column: column };
				}


				var result = parseFunctions[startRule]();

				/*
				 * The parser is now in one of the following three states:
				 *
				 * 1. The parser successfully parsed the whole input.
				 *
				 *    - |result !== null|
				 *    - |pos === input.length|
				 *    - |rightmostFailuresExpected| may or may not contain something
				 *
				 * 2. The parser successfully parsed only a part of the input.
				 *
				 *    - |result !== null|
				 *    - |pos < input.length|
				 *    - |rightmostFailuresExpected| may or may not contain something
				 *
				 * 3. The parser did not successfully parse any part of the input.
				 *
				 *   - |result === null|
				 *   - |pos === 0|
				 *   - |rightmostFailuresExpected| contains at least one failure
				 *
				 * All code following this comment (including called functions) must
				 * handle these states.
				 */
				if (result === null || pos !== input.length) {
					var offset = Math.max(pos, rightmostFailuresPos);
					var found = offset < input.length ? input.charAt(offset) : null;
					var errorPosition = computeErrorPosition();

					throw new this.SyntaxError(
						cleanupExpected(rightmostFailuresExpected),
						found,
						offset,
						errorPosition.line,
						errorPosition.column
					);
				}

				return result;
			},

			/* Returns the parser source code. */
			toSource: function() { return this._source; }
		};

		/* Thrown when a parser encounters a syntax error. */

		result.SyntaxError = function(expected, found, offset, line, column) {
			function buildMessage(expected, found) {
				var expectedHumanized, foundHumanized;

				switch (expected.length) {
					case 0:
						expectedHumanized = "end of input";
						break;
					case 1:
						expectedHumanized = expected[0];
						break;
					default:
						expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
							+ " or "
							+ expected[expected.length - 1];
				}

				foundHumanized = found ? quote(found) : "end of input";

				return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
			}

			this.name = "SyntaxError";
			this.expected = expected;
			this.found = found;
			this.message = buildMessage(expected, found);
			this.offset = offset;
			this.line = line;
			this.column = column;
		};

		result.SyntaxError.prototype = Error.prototype;

		return result;
	})();

	// Description: This model contains the implementation for "instructions" included in the EPUB CFI domain specific language (DSL).
//   Lexing and parsing a CFI produces a set of executable instructions for processing a CFI (represented in the AST). 
//   This object contains a set of functions that implement each of the executable instructions in the AST. 

	EPUBcfi.CFIInstructions = {

		// ------------------------------------------------------------------------------------ //
		//  "PUBLIC" METHODS (THE API)                                                          //
		// ------------------------------------------------------------------------------------ //

		// Description: Follows a step
		// Rationale: The use of children() is important here, as this jQuery method returns a tree of xml nodes, EXCLUDING
		//   CDATA and text nodes. When we index into the set of child elements, we are assuming that text nodes have been
		//   excluded.
		// REFACTORING CANDIDATE: This should be called "followIndexStep"
		getNextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {

			// Find the jquery index for the current node
			var $targetNode;
			if (CFIStepValue % 2 == 0) {

				$targetNode = this.elementNodeStep(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);
			}
			else {

				$targetNode = this.inferTargetTextNode(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);
			}

			return $targetNode;
		},

		// Description: This instruction executes an indirection step, where a resource is retrieved using a
		//   link contained on a attribute of the target element. The attribute that contains the link differs
		//   depending on the target.
		// Note: Iframe indirection will (should) fail if the iframe is not from the same domain as its containing script due to
		//   the cross origin security policy
		followIndirectionStep : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {

			var that = this;
			var $contentDocument;
			var $blacklistExcluded;
			var $startElement;
			var $targetNode;

			// TODO: This check must be expanded to all the different types of indirection step
			// Only expects iframes, at the moment
			if ($currNode === undefined || !$currNode.is("iframe")) {

				throw EPUBcfi.NodeTypeError($currNode, "expected an iframe element");
			}

			// Check node type; only iframe indirection is handled, at the moment
			if ($currNode.is("iframe")) {

				// Get content
				$contentDocument = $currNode.contents();

				// Go to the first XHTML element, which will be the first child of the top-level document object
				$blacklistExcluded = this.applyBlacklist($contentDocument.children(), classBlacklist, elementBlacklist, idBlacklist);
				$startElement = $($blacklistExcluded[0]);

				// Follow an index step
				$targetNode = this.getNextNode(CFIStepValue, $startElement, classBlacklist, elementBlacklist, idBlacklist);

				// Return that shit!
				return $targetNode;
			}

			// TODO: Other types of indirection
			// TODO: $targetNode.is("embed")) : src
			// TODO: ($targetNode.is("object")) : data
			// TODO: ($targetNode.is("image") || $targetNode.is("xlink:href")) : xlink:href
		},

		// Description: Injects an element at the specified text node
		// Arguments: a cfi text termination string, a jquery object to the current node
		// REFACTORING CANDIDATE: Rename this to indicate that it injects into a text terminus
		textTermination : function ($currNode, textOffset, elementToInject) {

			var $injectedElement;
			// Get the first node, this should be a text node
			if ($currNode === undefined) {

				throw EPUBcfi.NodeTypeError($currNode, "expected a terminating node, or node list");
			}
			else if ($currNode.length === 0) {

				throw EPUBcfi.TerminusError("Text", "Text offset:" + textOffset, "no nodes found for termination condition");
			}

			$injectedElement = this.injectCFIMarkerIntoText($currNode, textOffset, elementToInject);
			return $injectedElement;
		},

		// Description: Checks that the id assertion for the node target matches that on
		//   the found node.
		targetIdMatchesIdAssertion : function ($foundNode, idAssertion) {

			if ($foundNode.attr("id") === idAssertion) {

				return true;
			}
			else {

				return false;
			}
		},

		// ------------------------------------------------------------------------------------ //
		//  "PRIVATE" HELPERS                                                                   //
		// ------------------------------------------------------------------------------------ //

		// Description: Step reference for xml element node. Expected that CFIStepValue is an even integer
		elementNodeStep : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {

			var $targetNode;
			var $blacklistExcluded;
			var numElements;
			var jqueryTargetNodeIndex = (CFIStepValue / 2) - 1;

			$blacklistExcluded = this.applyBlacklist($currNode.children(), classBlacklist, elementBlacklist, idBlacklist);
			numElements = $blacklistExcluded.length;

			if (this.indexOutOfRange(jqueryTargetNodeIndex, numElements)) {

				throw EPUBcfi.OutOfRangeError(jqueryTargetNodeIndex, numElements - 1, "");
			}

			$targetNode = $($blacklistExcluded[jqueryTargetNodeIndex]);
			return $targetNode;
		},

		retrieveItemRefHref : function ($itemRefElement, $packageDocument) {

			return $("#" + $itemRefElement.attr("idref"), $packageDocument).attr("href");
		},

		indexOutOfRange : function (targetIndex, numChildElements) {

			return (targetIndex > numChildElements - 1) ? true : false;
		},

		// Rationale: In order to inject an element into a specific position, access to the parent object
		//   is required. This is obtained with the jquery parent() method. An alternative would be to
		//   pass in the parent with a filtered list containing only children that are part of the target text node.
		injectCFIMarkerIntoText : function ($textNodeList, textOffset, elementToInject) {

			var nodeNum;
			var currNodeLength;
			var currTextPosition = 0;
			var nodeOffset;
			var originalText;
			var $injectedNode;
			var $newTextNode;
			// The iteration counter may be incorrect here (should be $textNodeList.length - 1 ??)
			for (nodeNum = 0; nodeNum <= $textNodeList.length; nodeNum++) {

				if ($textNodeList[nodeNum].nodeType === 3) {

					currNodeMaxIndex = $textNodeList[nodeNum].nodeValue.length  + currTextPosition;
					nodeOffset = textOffset - currTextPosition;

					if (currNodeMaxIndex > textOffset) {

						// This node is going to be split and the components re-inserted
						originalText = $textNodeList[nodeNum].nodeValue;

						// Before part
						$textNodeList[nodeNum].nodeValue = originalText.slice(0, nodeOffset);

						// Injected element
						$injectedNode = $(elementToInject).insertAfter($textNodeList.eq(nodeNum));

						// After part
						$newTextNode = $(document.createTextNode(originalText.slice(nodeOffset, originalText.length)));
						$($newTextNode).insertAfter($injectedNode);

						return $injectedNode;
					} else if (currNodeMaxIndex == textOffset){
						$injectedNode = $(elementToInject).insertAfter($textNodeList.eq(nodeNum));
						return $injectedNode;
					}
					else {

						currTextPosition = currNodeMaxIndex;
					}
				}
			}

			throw EPUBcfi.TerminusError("Text", "Text offset:" + textOffset, "The offset exceeded the length of the text");
		},

		// Rationale: In order to inject an element into a specific position, access to the parent object
		//   is required. This is obtained with the jquery parent() method. An alternative would be to
		//   pass in the parent with a filtered list containing only children that are part of the target text node.

		// Description: This method finds a target text node and then injects an element into the appropriate node
		// Rationale: The possibility that cfi marker elements have been injected into a text node at some point previous to
		//   this method being called (and thus splitting the original text node into two separate text nodes) necessitates that
		//   the set of nodes that compromised the original target text node are inferred and returned.
		// Notes: Passed a current node. This node should have a set of elements under it. This will include at least one text node,
		//   element nodes (maybe), or possibly a mix.
		// REFACTORING CANDIDATE: This method is pretty long (and confusing). Worth investigating to see if it can be refactored into something clearer.
		inferTargetTextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {

			var $elementsWithoutMarkers;
			var currLogicalTextNodeIndex;
			var targetLogicalTextNodeIndex;
			var nodeNum;
			var $targetTextNodeList;
			var prevNodeWasTextNode;

			// Remove any cfi marker elements from the set of elements.
			// Rationale: A filtering function is used, as simply using a class selector with jquery appears to
			//   result in behaviour where text nodes are also filtered out, along with the class element being filtered.
			$elementsWithoutMarkers = this.applyBlacklist($currNode.contents(), classBlacklist, elementBlacklist, idBlacklist);

			// Convert CFIStepValue to logical index; assumes odd integer for the step value
			targetLogicalTextNodeIndex = ((parseInt(CFIStepValue) + 1) / 2) - 1;

			// Set text node position counter
			currLogicalTextNodeIndex = 0;
			prevNodeWasTextNode = false;
			$targetTextNodeList = $elementsWithoutMarkers.filter(
				function () {

					if (currLogicalTextNodeIndex === targetLogicalTextNodeIndex) {

						// If it's a text node
						if (this.nodeType === Node.TEXT_NODE) {
							prevNodeWasTextNode = true;
							return true;
						}
						// Rationale: The logical text node position is only incremented once a group of text nodes (a single logical
						//   text node) has been passed by the loop.
						else if (prevNodeWasTextNode && (this.nodeType !== Node.TEXT_NODE)) {
							currLogicalTextNodeIndex++;
							prevNodeWasTextNode = false;
							return false;
						}
					}
					// Don't return any elements
					else {

						if (this.nodeType === Node.TEXT_NODE) {
							prevNodeWasTextNode = true;
						}
						else if (prevNodeWasTextNode && (this.nodeType !== Node.TEXT_NODE) && (this !== $elementsWithoutMarkers.lastChild)) {
							currLogicalTextNodeIndex++;
							prevNodeWasTextNode = false;
						}

						return false;
					}
				}
			);

			// The filtering above should have counted the number of "logical" text nodes; this can be used to
			// detect out of range errors
			if ($targetTextNodeList.length === 0) {
				throw EPUBcfi.OutOfRangeError(logicalTargetTextNodeIndex, currLogicalTextNodeIndex, "Index out of range");
			}

			// return the text node list
			return $targetTextNodeList;
		},

		applyBlacklist : function ($elements, classBlacklist, elementBlacklist, idBlacklist) {

			var $filteredElements;

			$filteredElements = $elements.filter(
				function () {

					var $currElement = $(this);
					var includeInList = true;

					if (classBlacklist) {

						// Filter each element with the class type
						$.each(classBlacklist, function (index, value) {

							if ($currElement.hasClass(value)) {
								includeInList = false;

								// Break this loop
								return false;
							}
						});
					}

					if (elementBlacklist) {

						// For each type of element
						$.each(elementBlacklist, function (index, value) {

							if ($currElement.is(value)) {
								includeInList = false;

								// Break this loop
								return false;
							}
						});
					}

					if (idBlacklist) {

						// For each type of element
						$.each(idBlacklist, function (index, value) {

							if ($currElement.attr("id") === value) {
								includeInList = false;

								// Break this loop
								return false;
							}
						});
					}

					return includeInList;
				}
			);

			return $filteredElements;
		}
	};



	// Description: This is an interpreter that inteprets an Abstract Syntax Tree (AST) for a CFI. The result of executing the interpreter
//   is to inject an element, or set of elements, into an EPUB content document (which is just an XHTML document). These element(s) will
//   represent the position or area in the EPUB referenced by a CFI.
// Rationale: The AST is a clean and readable expression of the step-terminus structure of a CFI. Although building an interpreter adds to the
//   CFI infrastructure, it provides a number of benefits. First, it emphasizes a clear separation of concerns between lexing/parsing a
//   CFI, which involves some complexity related to escaped and special characters, and the execution of the underlying set of steps 
//   represented by the CFI. Second, it will be easier to extend the interpreter to account for new/altered CFI steps (say for references
//   to vector objects or multiple CFIs) than if lexing, parsing and interpretation were all handled in a single step. Finally, Readium's objective is 
//   to demonstrate implementation of the EPUB 3.0 spec. An implementation with a strong separation of concerns that conforms to 
//   well-understood patterns for DSL processing should be easier to communicate, analyze and understand. 
// REFACTORING CANDIDATE: node type errors shouldn't really be possible if the CFI syntax is correct and the parser is error free. 
//   Might want to make the script die in those instances, once the grammar and interpreter are more stable. 
// REFACTORING CANDIDATE: The use of the 'nodeType' property is confusing as this is a DOM node property and the two are unrelated. 
//   Whoops. There shouldn't be any interference, however, I think this should be changed. 

	EPUBcfi.Interpreter = {

		// ------------------------------------------------------------------------------------ //
		//  "PUBLIC" METHODS (THE API)                                                          //
		// ------------------------------------------------------------------------------------ //

		// Description: Find the content document referenced by the spine item. This should be the spine item
		//   referenced by the first indirection step in the CFI.
		// Rationale: This method is a part of the API so that the reading system can "interact" the content document
		//   pointed to by a CFI. If this is not a separate step, the processing of the CFI must be tightly coupled with
		//   the reading system, as it stands now.
		getContentDocHref : function (CFI, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {

			var $packageDocument = $(packageDocument);
			var decodedCFI = decodeURI(CFI);
			var CFIAST = EPUBcfi.Parser.parse(decodedCFI);

			if (!CFIAST || CFIAST.type !== "CFIAST") {
				throw EPUBcfi.NodeTypeError(CFIAST, "expected CFI AST root node");
			}

			// Interpet the path node (the package document step)
			var $packageElement = $($("package", $packageDocument)[0]);
			var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $packageElement, classBlacklist, elementBlacklist, idBlacklist);
			foundHref = this.searchLocalPathForHref($currElement, $packageDocument, CFIAST.cfiString.localPath, classBlacklist, elementBlacklist, idBlacklist);

			if (foundHref) {
				return foundHref;
			}
			else {
				return undefined;
			}
		},

		// Description: Inject an arbitrary html element into a position in a content document referenced by a CFI
		injectElement : function (CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist) {

			var decodedCFI = decodeURI(CFI);
			var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
			var indirectionNode;
			var indirectionStepNum;
			var $currElement;

			// Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning
			//   of the indirection step that referenced the content document.
			// Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion
			indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);
			indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];
			indirectionNode.type = "indexStep";

			// Interpret the rest of the steps
			$currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

			// TODO: detect what kind of terminus; for now, text node termini are the only kind implemented
			$currElement = this.interpretTextTerminusNode(CFIAST.cfiString.localPath.termStep, $currElement, elementToInject);

			// Return the element that was injected into
			return $currElement;
		},

		// Description: Inject an arbitrary html element into a position in a content document referenced by a CFI
		injectRangeElements : function (rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist) {

			var decodedCFI = decodeURI(rangeCFI);
			var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
			var indirectionNode;
			var indirectionStepNum;
			var $currElement;
			var $range1TargetElement;
			var $range2TargetElement;

			// Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning
			//   of the indirection step that referenced the content document.
			// Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion
			indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);
			indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];
			indirectionNode.type = "indexStep";

			// Interpret the rest of the steps in the first local path
			$currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

			// Interpret the first range local_path
			$range1TargetElement = this.interpretLocalPath(CFIAST.cfiString.range1, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);
			$range1TargetElement = this.interpretTextTerminusNode(CFIAST.cfiString.range1.termStep, $range1TargetElement, startElementToInject);

			// Interpret the second range local_path
			$range2TargetElement = this.interpretLocalPath(CFIAST.cfiString.range2, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);
			$range2TargetElement = this.interpretTextTerminusNode(CFIAST.cfiString.range2.termStep, $range2TargetElement, endElementToInject);

			// Return the element that was injected into
			return {
				startElement : $range1TargetElement[0],
				endElement : $range2TargetElement[0]
			};
		},

		// Description: This method will return the element or node (say, a text node) that is the final target of the
		//   the CFI.
		getTargetElement : function (CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {

			var decodedCFI = decodeURI(CFI);
			var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
			var indirectionNode;
			var indirectionStepNum;
			var $currElement;

			// Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning
			//   of the indirection step that referenced the content document.
			// Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion
			indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);
			indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];
			indirectionNode.type = "indexStep";

			// Interpret the rest of the steps
			$currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

			// Return the element at the end of the CFI
			return $currElement;
		},

		getRangeTargetElements : function (rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {

			var decodedCFI = decodeURI(rangeCFI);
			var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
			var indirectionNode;
			var indirectionStepNum;
			var $currElement;
			var $range1TargetElement;
			var $range2TargetElement;

			// Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning
			//   of the indirection step that referenced the content document.
			// Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion
			indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);
			indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];
			indirectionNode.type = "indexStep";

			// Interpret the rest of the steps
			$currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

			// Interpret first range local_path
			$range1TargetElement = this.interpretLocalPath(CFIAST.cfiString.range1, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);

			// Interpret second range local_path
			$range2TargetElement = this.interpretLocalPath(CFIAST.cfiString.range2, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);

			// Return the element at the end of the CFI
			return {
				startElement : $range1TargetElement[0],
				endElement : $range2TargetElement[0]
			};
		},

		// Description: This method allows a "partial" CFI to be used to reference a target in a content document, without a
		//   package document CFI component.
		// Arguments: {
		//     contentDocumentCFI : This is a partial CFI that represents a path in a content document only. This partial must be
		//        syntactically valid, even though it references a path starting at the top of a content document (which is a CFI that
		//        that has no defined meaning in the spec.)
		//     contentDocument : A DOM representation of the content document to which the partial CFI refers.
		// }
		// Rationale: This method exists to meet the requirements of the Readium-SDK and should be used with care
		getTargetElementWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {

			var decodedCFI = decodeURI(contentDocumentCFI);
			var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
			var indirectionNode;

			// Interpret the path node
			var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

			// Interpret the rest of the steps
			$currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);

			// Return the element at the end of the CFI
			return $currElement;
		},

		// Description: This method allows a "partial" CFI to be used, with a content document, to return the text node and offset
		//    referenced by the partial CFI.
		// Arguments: {
		//     contentDocumentCFI : This is a partial CFI that represents a path in a content document only. This partial must be
		//        syntactically valid, even though it references a path starting at the top of a content document (which is a CFI that
		//        that has no defined meaning in the spec.)
		//     contentDocument : A DOM representation of the content document to which the partial CFI refers.
		// }
		// Rationale: This method exists to meet the requirements of the Readium-SDK and should be used with care
		getTextTerminusInfoWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {

			var decodedCFI = decodeURI(contentDocumentCFI);
			var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
			var indirectionNode;
			var textOffset;

			// Interpret the path node
			var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

			// Interpret the rest of the steps
			$currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);

			// Return the element at the end of the CFI
			textOffset = parseInt(CFIAST.cfiString.localPath.termStep.offsetValue);
			return { textNode : $currElement,
				textOffset : textOffset
			};
		},

		// ------------------------------------------------------------------------------------ //
		//  "PRIVATE" HELPERS                                                                   //
		// ------------------------------------------------------------------------------------ //

		getFirstIndirectionStepNum : function (CFIAST) {

			// Find the first indirection step in the local path; follow it like a regular step, as the step in the content document it
			//   references is already loaded and has been passed to this method
			var stepNum = 0;
			for (stepNum; stepNum <= CFIAST.cfiString.localPath.steps.length - 1 ; stepNum++) {

				nextStepNode = CFIAST.cfiString.localPath.steps[stepNum];
				if (nextStepNode.type === "indirectionStep") {
					return stepNum;
				}
			}
		},

		// REFACTORING CANDIDATE: cfiString node and start step num could be merged into one argument, by simply passing the
		//   starting step... probably a good idea, this would make the meaning of this method clearer.
		interpretLocalPath : function (localPathNode, startStepNum, $currElement, classBlacklist, elementBlacklist, idBlacklist) {

			var stepNum = startStepNum;
			var nextStepNode;
			for (stepNum; stepNum <= localPathNode.steps.length - 1 ; stepNum++) {

				nextStepNode = localPathNode.steps[stepNum];
				if (nextStepNode.type === "indexStep") {

					$currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
				}
				else if (nextStepNode.type === "indirectionStep") {

					$currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
				}
			}

			return $currElement;
		},

		interpretIndexStepNode : function (indexStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist) {

			// Check node type; throw error if wrong type
			if (indexStepNode === undefined || indexStepNode.type !== "indexStep") {

				throw EPUBcfi.NodeTypeError(indexStepNode, "expected index step node");
			}

			// Index step
			var $stepTarget = EPUBcfi.CFIInstructions.getNextNode(indexStepNode.stepLength, $currElement, classBlacklist, elementBlacklist, idBlacklist);

			// Check the id assertion, if it exists
			if (indexStepNode.idAssertion) {

				if (!EPUBcfi.CFIInstructions.targetIdMatchesIdAssertion($stepTarget, indexStepNode.idAssertion)) {

					throw EPUBcfi.CFIAssertionError(indexStepNode.idAssertion, $stepTarget.attr('id'), "Id assertion failed");
				}
			}

			return $stepTarget;
		},

		interpretIndirectionStepNode : function (indirectionStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist) {

			// Check node type; throw error if wrong type
			if (indirectionStepNode === undefined || indirectionStepNode.type !== "indirectionStep") {

				throw EPUBcfi.NodeTypeError(indirectionStepNode, "expected indirection step node");
			}

			// Indirection step
			var $stepTarget = EPUBcfi.CFIInstructions.followIndirectionStep(
				indirectionStepNode.stepLength,
				$currElement,
				classBlacklist,
				elementBlacklist);

			// Check the id assertion, if it exists
			if (indirectionStepNode.idAssertion) {

				if (!EPUBcfi.CFIInstructions.targetIdMatchesIdAssertion($stepTarget, indirectionStepNode.idAssertion)) {

					throw EPUBcfi.CFIAssertionError(indirectionStepNode.idAssertion, $stepTarget.attr('id'), "Id assertion failed");
				}
			}

			return $stepTarget;
		},

		// REFACTORING CANDIDATE: The logic here assumes that a user will always want to use this terminus
		//   to inject content into the found node. This will not always be the case, and different types of interpretation
		//   are probably desired.
		interpretTextTerminusNode : function (terminusNode, $currElement, elementToInject) {

			if (terminusNode === undefined || terminusNode.type !== "textTerminus") {

				throw EPUBcfi.NodeTypeError(terminusNode, "expected text terminus node");
			}

			var $injectedElement = EPUBcfi.CFIInstructions.textTermination(
				$currElement,
				terminusNode.offsetValue,
				elementToInject
			);

			return $injectedElement;
		},

		searchLocalPathForHref : function ($currElement, $packageDocument, localPathNode, classBlacklist, elementBlacklist, idBlacklist) {

			// Interpret the first local_path node, which is a set of steps and and a terminus condition
			var stepNum = 0;
			var nextStepNode;
			for (stepNum = 0 ; stepNum <= localPathNode.steps.length - 1 ; stepNum++) {

				nextStepNode = localPathNode.steps[stepNum];
				if (nextStepNode.type === "indexStep") {

					$currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
				}
				else if (nextStepNode.type === "indirectionStep") {

					$currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
				}

				// Found the content document href referenced by the spine item
				if ($currElement.is("itemref")) {

					return EPUBcfi.CFIInstructions.retrieveItemRefHref($currElement, $packageDocument);
				}
			}

			return undefined;
		}
	};
	// Description: This is a set of runtime errors that the CFI interpreter can throw.
// Rationale: These error types extend the basic javascript error object so error things like the stack trace are 
//   included with the runtime errors. 

// REFACTORING CANDIDATE: This type of error may not be required in the long run. The parser should catch any syntax errors, 
//   provided it is error-free, and as such, the AST should never really have any node type errors, which are essentially errors
//   in the structure of the AST. This error should probably be refactored out when the grammar and interpreter are more stable.
	EPUBcfi.NodeTypeError = function (node, message) {

		function NodeTypeError () {

			this.node = node;
		}

		NodeTypeError.prototype = new Error(message);
		NodeTypeError.constructor = NodeTypeError;

		return new NodeTypeError();
	};

// REFACTORING CANDIDATE: Might make sense to include some more specifics about the out-of-rangeyness.
	EPUBcfi.OutOfRangeError = function (targetIndex, maxIndex, message) {

		function OutOfRangeError () {

			this.targetIndex = targetIndex;
			this.maxIndex = maxIndex;
		}

		OutOfRangeError.prototype = new Error(message);
		OutOfRangeError.constructor = OutOfRangeError()

		return new OutOfRangeError();
	};

// REFACTORING CANDIDATE: This is a bit too general to be useful. When I have a better understanding of the type of errors
//   that can occur with the various terminus conditions, it'll make more sense to revisit this. 
	EPUBcfi.TerminusError = function (terminusType, terminusCondition, message) {

		function TerminusError () {

			this.terminusType = terminusType;
			this.terminusCondition = terminusCondition;
		}

		TerminusError.prototype = new Error(message);
		TerminusError.constructor = TerminusError();

		return new TerminusError();
	};

	EPUBcfi.CFIAssertionError = function (expectedAssertion, targetElementAssertion, message) {

		function CFIAssertionError () {

			this.expectedAssertion = expectedAssertion;
			this.targetElementAssertion = targetElementAssertion;
		}

		CFIAssertionError.prototype = new Error(message);
		CFIAssertionError.constructor = CFIAssertionError();

		return new CFIAssertionError();
	};

	EPUBcfi.Generator = {

		// ------------------------------------------------------------------------------------ //
		//  "PUBLIC" METHODS (THE API)                                                          //
		// ------------------------------------------------------------------------------------ //

		generateCharOffsetRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {

			var docRange;
			var commonAncestor;
			var $rangeStartParent;
			var $rangeEndParent;
			var range1OffsetStep;
			var range1CFI;
			var range2OffsetStep;
			var range2CFI;
			var commonCFIComponent;

			this.validateStartTextNode(rangeStartElement);
			this.validateStartTextNode(rangeEndElement);

			// Parent element is the same
			if ($(rangeStartElement).parent()[0] === $(rangeEndElement).parent()[0]) {
				range1OffsetStep = this.createCFITextNodeStep($(rangeStartElement), startOffset, classBlacklist, elementBlacklist, idBlacklist);
				range2OffsetStep = this.createCFITextNodeStep($(rangeEndElement), endOffset, classBlacklist, elementBlacklist, idBlacklist);
				commonCFIComponent = this.createCFIElementSteps($(rangeStartElement).parent(), "html", classBlacklist, elementBlacklist, idBlacklist);
				return commonCFIComponent.substring(1, commonCFIComponent.length) + "," + range1OffsetStep + "," + range2OffsetStep;
			}
			else {

				// Create a document range to find the common ancestor
				docRange = document.createRange();
				docRange.setStart(rangeStartElement, startOffset);
				docRange.setEnd(rangeEndElement, endOffset);
				commonAncestor = docRange.commonAncestorContainer;

				// Generate terminating offset and range 1
				range1OffsetStep = this.createCFITextNodeStep($(rangeStartElement), startOffset, classBlacklist, elementBlacklist, idBlacklist);
				$rangeStartParent = $(rangeStartElement).parent();
				if ($rangeStartParent[0] === commonAncestor) {
					// rangeStartElement is a text child node of the commonAncestor, so it's CFI sub-path is only the text node step:
					range1CFI = range1OffsetStep;
				} else {
					range1CFI = this.createCFIElementSteps($rangeStartParent, commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range1OffsetStep;
				}

				// Generate terminating offset and range 2
				range2OffsetStep = this.createCFITextNodeStep($(rangeEndElement), endOffset, classBlacklist, elementBlacklist, idBlacklist);
				$rangeEndParent = $(rangeEndElement).parent();
				if ($rangeEndParent[0] === commonAncestor) {
					// rangeEndElement is a text child node of the commonAncestor, so it's CFI sub-path is only the text node step:
					range2CFI = range2OffsetStep;
				} else {
					range2CFI = this.createCFIElementSteps($rangeEndParent, commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range2OffsetStep;
				}

				// Generate shared component
				commonCFIComponent = this.createCFIElementSteps($(commonAncestor), "html", classBlacklist, elementBlacklist, idBlacklist);

				// Return the result
				return commonCFIComponent.substring(1, commonCFIComponent.length) + "," + range1CFI + "," + range2CFI;
			}
		},

		generateElementRangeComponent : function (rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist) {

			var docRange;
			var commonAncestor;
			var range1CFI;
			var range2CFI;
			var commonCFIComponent;

			this.validateStartElement(rangeStartElement);
			this.validateStartElement(rangeEndElement);

			if (rangeStartElement === rangeEndElement) {
				throw new Error("Start and end element cannot be the same for a CFI range");
			}

			// Create a document range to find the common ancestor
			docRange = document.createRange();
			docRange.setStart(rangeStartElement, 0);
			docRange.setEnd(rangeEndElement, rangeEndElement.childNodes.length);
			commonAncestor = docRange.commonAncestorContainer;

			// Generate range 1
			range1CFI = this.createCFIElementSteps($(rangeStartElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);

			// Generate range 2
			range2CFI = this.createCFIElementSteps($(rangeEndElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);

			// Generate shared component
			commonCFIComponent = this.createCFIElementSteps($(commonAncestor), "html", classBlacklist, elementBlacklist, idBlacklist);

			// Return the result
			return commonCFIComponent.substring(1, commonCFIComponent.length) + "," + range1CFI + "," + range2CFI;
		},

		generateRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {
			if(rangeStartElement.nodeType === Node.ELEMENT_NODE && rangeEndElement.nodeType === Node.ELEMENT_NODE){
				return this.generateElementRangeComponent(rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist);
			} else if(rangeStartElement.nodeType === Node.TEXT_NODE && rangeEndElement.nodeType === Node.TEXT_NODE){
				return this.generateCharOffsetRangeComponent(rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist);
			} else {
				var docRange;
				var range1CFI;
				var range1OffsetStep;
				var range2CFI;
				var range2OffsetStep;

				// Create a document range to find the common ancestor
				docRange = document.createRange();
				docRange.setStart(rangeStartElement, startOffset);
				docRange.setEnd(rangeEndElement, endOffset);
				commonAncestor = docRange.commonAncestorContainer;

				if(rangeStartElement.nodeType === Node.ELEMENT_NODE){
					this.validateStartElement(rangeStartElement);
					range1CFI = this.createCFIElementSteps($(rangeStartElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);
				} else {
					this.validateStartTextNode(rangeStartElement);
					// Generate terminating offset and range 1
					range1OffsetStep = this.createCFITextNodeStep($(rangeStartElement), startOffset, classBlacklist, elementBlacklist, idBlacklist);
					if($(rangeStartElement).parent().is(commonAncestor)){
						range1CFI = range1OffsetStep;
					} else {
						range1CFI = this.createCFIElementSteps($(rangeStartElement).parent(), commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range1OffsetStep;
					}
				}

				if(rangeEndElement.nodeType === Node.ELEMENT_NODE){
					this.validateStartElement(rangeEndElement);
					range2CFI = this.createCFIElementSteps($(rangeEndElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);
				} else {
					this.validateStartTextNode(rangeEndElement);
					// Generate terminating offset and range 2
					range2OffsetStep = this.createCFITextNodeStep($(rangeEndElement), endOffset, classBlacklist, elementBlacklist, idBlacklist);
					if($(rangeEndElement).parent().is(commonAncestor)){
						range2CFI = range2OffsetStep;
					} else {
						range2CFI = this.createCFIElementSteps($(rangeEndElement).parent(), commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range2OffsetStep;
					}
				}

				// Generate shared component
				commonCFIComponent = this.createCFIElementSteps($(commonAncestor), "html", classBlacklist, elementBlacklist, idBlacklist);

				// Return the result
				return commonCFIComponent.substring(1, commonCFIComponent.length) + "," + range1CFI + "," + range2CFI;
			}
		},

		// Description: Generates a character offset CFI
		// Arguments: The text node that contains the offset referenced by the cfi, the offset value, the name of the
		//   content document that contains the text node, the package document for this EPUB.
		generateCharacterOffsetCFIComponent : function (startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {

			var textNodeStep;
			var contentDocCFI;
			var $itemRefStartNode;
			var packageDocCFI;

			this.validateStartTextNode(startTextNode, characterOffset);

			// Create the text node step
			textNodeStep = this.createCFITextNodeStep($(startTextNode), characterOffset, classBlacklist, elementBlacklist, idBlacklist);

			// Call the recursive method to create all the steps up to the head element of the content document (the "html" element)
			contentDocCFI = this.createCFIElementSteps($(startTextNode).parent(), "html", classBlacklist, elementBlacklist, idBlacklist) + textNodeStep;
			return contentDocCFI.substring(1, contentDocCFI.length);
		},

		generateElementCFIComponent : function (startElement, classBlacklist, elementBlacklist, idBlacklist) {

			var contentDocCFI;
			var $itemRefStartNode;
			var packageDocCFI;

			this.validateStartElement(startElement);

			// Call the recursive method to create all the steps up to the head element of the content document (the "html" element)
			contentDocCFI = this.createCFIElementSteps($(startElement), "html", classBlacklist, elementBlacklist, idBlacklist);

			// Remove the !
			return contentDocCFI.substring(1, contentDocCFI.length);
		},

		generatePackageDocumentCFIComponent : function (contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {

			this.validateContentDocumentName(contentDocumentName);
			this.validatePackageDocument(packageDocument, contentDocumentName);

			// Get the start node (itemref element) that references the content document
			$itemRefStartNode = $("itemref[idref='" + contentDocumentName + "']", $(packageDocument));

			// Create the steps up to the top element of the package document (the "package" element)
			packageDocCFIComponent = this.createCFIElementSteps($itemRefStartNode, "package", classBlacklist, elementBlacklist, idBlacklist);

			// Append an !; this assumes that a CFI content document CFI component will be appended at some point
			return packageDocCFIComponent + "!";
		},

		generatePackageDocumentCFIComponentWithSpineIndex : function (spineIndex, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {

			// Get the start node (itemref element) that references the content document
			$itemRefStartNode = $($("spine", packageDocument).children()[spineIndex]);

			// Create the steps up to the top element of the package document (the "package" element)
			packageDocCFIComponent = this.createCFIElementSteps($itemRefStartNode, "package", classBlacklist, elementBlacklist, idBlacklist);

			// Append an !; this assumes that a CFI content document CFI component will be appended at some point
			return packageDocCFIComponent + "!";
		},

		generateCompleteCFI : function (packageDocumentCFIComponent, contentDocumentCFIComponent) {

			return "epubcfi(" + packageDocumentCFIComponent + contentDocumentCFIComponent + ")";
		},

		// ------------------------------------------------------------------------------------ //
		//  "PRIVATE" HELPERS                                                                   //
		// ------------------------------------------------------------------------------------ //

		validateStartTextNode : function (startTextNode, characterOffset) {

			// Check that the text node to start from IS a text node
			if (!startTextNode) {
				throw new EPUBcfi.NodeTypeError(startTextNode, "Cannot generate a character offset from a starting point that is not a text node");
			} else if (startTextNode.nodeType != 3) {
				throw new EPUBcfi.NodeTypeError(startTextNode, "Cannot generate a character offset from a starting point that is not a text node");
			}

			// Check that the character offset is within a valid range for the text node supplied
			if (characterOffset < 0) {
				throw new EPUBcfi.OutOfRangeError(characterOffset, 0, "Character offset cannot be less than 0");
			}
			else if (characterOffset > startTextNode.nodeValue.length) {
				throw new EPUBcfi.OutOfRangeError(characterOffset, startTextNode.nodeValue.length - 1, "character offset cannot be greater than the length of the text node");
			}
		},

		validateStartElement : function (startElement) {

			if (!startElement) {
				throw new EPUBcfi.NodeTypeError(startElement, "CFI target element is undefined");
			}

			if (!(startElement.nodeType && startElement.nodeType === 1)) {
				throw new EPUBcfi.NodeTypeError(startElement, "CFI target element is not an HTML element");
			}
		},

		validateContentDocumentName : function (contentDocumentName) {

			// Check that the idref for the content document has been provided
			if (!contentDocumentName) {
				throw new Error("The idref for the content document, as found in the spine, must be supplied");
			}
		},

		validatePackageDocument : function (packageDocument, contentDocumentName) {

			// Check that the package document is non-empty and contains an itemref element for the supplied idref
			if (!packageDocument) {
				throw new Error("A package document must be supplied to generate a CFI");
			}
			else if ($($("itemref[idref='" + contentDocumentName + "']", packageDocument)[0]).length === 0) {
				throw new Error("The idref of the content document could not be found in the spine");
			}
		},

		// Description: Creates a CFI terminating step to a text node, with a character offset
		// REFACTORING CANDIDATE: Some of the parts of this method could be refactored into their own methods
		createCFITextNodeStep : function ($startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {

			var $parentNode;
			var $contentsExcludingMarkers;
			var CFIIndex;
			var indexOfTextNode;
			var preAssertion;
			var preAssertionStartIndex;
			var textLength;
			var postAssertion;
			var postAssertionEndIndex;

			// Find text node position in the set of child elements, ignoring any blacklisted elements
			$parentNode = $startTextNode.parent();
			$contentsExcludingMarkers = EPUBcfi.CFIInstructions.applyBlacklist($parentNode.contents(), classBlacklist, elementBlacklist, idBlacklist);

			// Find the text node index in the parent list, inferring nodes that were originally a single text node
			var prevNodeWasTextNode;
			var indexOfFirstInSequence;
			var textNodeOnlyIndex = 0;
			var characterOffsetSinceUnsplit = 0;
			var finalCharacterOffsetInSequence = 0;
			$.each($contentsExcludingMarkers,
				function (index) {

					// If this is a text node, check if it matches and return the current index
					if (this.nodeType === Node.TEXT_NODE) {

						if (this === $startTextNode[0]) {

							// Set index as the first in the adjacent sequence of text nodes, or as the index of the current node if this
							//   node is a standard one sandwiched between two element nodes.
							if (prevNodeWasTextNode) {
								indexOfTextNode = indexOfFirstInSequence;
								finalCharacterOffsetInSequence = characterOffsetSinceUnsplit;
							}
							else {
								indexOfTextNode = textNodeOnlyIndex;
							}

							// Break out of .each loop
							return false;
						}

						// Save this index as the first in sequence of adjacent text nodes, if it is not already set by this point
						prevNodeWasTextNode = true;
						characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.length
						if (indexOfFirstInSequence === undefined) {
							indexOfFirstInSequence = textNodeOnlyIndex;
							textNodeOnlyIndex = textNodeOnlyIndex + 1;
						}
					}
					// This node is not a text node
					else {
						prevNodeWasTextNode = false;
						indexOfFirstInSequence = undefined;
						characterOffsetSinceUnsplit  = 0;
					}
				}
			);

			// Convert the text node index to a CFI odd-integer representation
			CFIIndex = (indexOfTextNode * 2) + 1;

			// TODO: text assertions are not in the grammar yet, I think, or they're just causing problems. This has
			//   been temporarily removed.

			// Add pre- and post- text assertions
			// preAssertionStartIndex = (characterOffset - 3 >= 0) ? characterOffset - 3 : 0;
			// preAssertion = $startTextNode[0].nodeValue.substring(preAssertionStartIndex, characterOffset);

			// textLength = $startTextNode[0].nodeValue.length;
			// postAssertionEndIndex = (characterOffset + 3 <= textLength) ? characterOffset + 3 : textLength;
			// postAssertion = $startTextNode[0].nodeValue.substring(characterOffset, postAssertionEndIndex);

			// Gotta infer the correct character offset, as well

			// Return the constructed CFI text node step
			return "/" + CFIIndex + ":" + (finalCharacterOffsetInSequence + characterOffset);
			// + "[" + preAssertion + "," + postAssertion + "]";
		},

		createCFIElementSteps : function ($currNode, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) {

			var $blacklistExcluded;
			var $parentNode;
			var currNodePosition;
			var CFIPosition;
			var idAssertion;
			var elementStep;

			// Find position of current node in parent list
			$blacklistExcluded = EPUBcfi.CFIInstructions.applyBlacklist($currNode.parent().children(), classBlacklist, elementBlacklist, idBlacklist);
			$.each($blacklistExcluded,
				function (index, value) {

					if (this === $currNode[0]) {

						currNodePosition = index;

						// Break loop
						return false;
					}
				});

			// Convert position to the CFI even-integer representation
			CFIPosition = (currNodePosition + 1) * 2;

			// Create CFI step with id assertion, if the element has an id
			if ($currNode.attr("id")) {
				elementStep = "/" + CFIPosition + "[" + $currNode.attr("id") + "]";
			}
			else {
				elementStep = "/" + CFIPosition;
			}

			// If a parent is an html element return the (last) step for this content document, otherwise, continue.
			//   Also need to check if the current node is the top-level element. This can occur if the start node is also the
			//   top level element.
			$parentNode = $currNode.parent();
			if ($parentNode.is(topLevelElement) || $currNode.is(topLevelElement)) {

				// If the top level node is a type from which an indirection step, add an indirection step character (!)
				// REFACTORING CANDIDATE: It is possible that this should be changed to: if (topLevelElement = 'package') do
				//   not return an indirection character. Every other type of top-level element may require an indirection
				//   step to navigate to, thus requiring that ! is always prepended.
				if (topLevelElement === 'html') {
					return "!" + elementStep;
				}
				else {
					return elementStep;
				}
			}
			else {
				return this.createCFIElementSteps($parentNode, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) + elementStep;
			}
		}
	};


	var interpreter = EPUBcfi.Interpreter;
	var generator = EPUBcfi.Generator;
	var instructions = EPUBcfi.CFIInstructions;


	if (global.EPUBcfi) {

		throw new Error('The EPUB cfi library has already been defined');
	} else {

		global.EPUBcfi = EPUBcfi;
	}

	// The public interface
	var CFIInstructions = EPUBcfi.CFIInstructions;
	var Parser = EPUBcfi.Parser;
	var OError = EPUBcfi.OutOfRangeError;
	var Interp = EPUBcfi.Interpreter;

	var NodeTypeError = EPUBcfi.NodeTypeError;
	var OutOfRangeError = EPUBcfi.OutOfRangeError;
	var TerminusError = EPUBcfi.TerminusError;
	var CFIAssertionError = EPUBcfi.CFIAssertionError;

	global.EPUBcfi = EPUBcfi =  {
		getContentDocHref : function (CFI, packageDocument) {
			return interpreter.getContentDocHref(CFI, packageDocument);
		},
		injectElement : function (CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist) {
			return interpreter.injectElement(CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist);
		},
		getTargetElement : function (CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {
			return interpreter.getTargetElement(CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);
		},
		getTargetElementWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {
			return interpreter.getTargetElementWithPartialCFI(contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);
		},
		getTextTerminusInfoWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {
			return interpreter.getTextTerminusInfoWithPartialCFI(contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);
		},
		generateCharacterOffsetCFIComponent : function (startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {
			return generator.generateCharacterOffsetCFIComponent(startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist);
		},
		generateElementCFIComponent : function (startElement, classBlacklist, elementBlacklist, idBlacklist) {
			return generator.generateElementCFIComponent(startElement, classBlacklist, elementBlacklist, idBlacklist);
		},
		generatePackageDocumentCFIComponent : function (contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {
			return generator.generatePackageDocumentCFIComponent(contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist);
		},
		generatePackageDocumentCFIComponentWithSpineIndex : function (spineIndex, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {
			return generator.generatePackageDocumentCFIComponentWithSpineIndex(spineIndex, packageDocument, classBlacklist, elementBlacklist, idBlacklist);
		},
		generateCompleteCFI : function (packageDocumentCFIComponent, contentDocumentCFIComponent) {
			return generator.generateCompleteCFI(packageDocumentCFIComponent, contentDocumentCFIComponent);
		},
		injectElementAtOffset : function ($textNodeList, textOffset, elementToInject) {
			return instructions.injectCFIMarkerIntoText($textNodeList, textOffset, elementToInject);
		},
		injectRangeElements : function (rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist) {
			return interpreter.injectRangeElements(rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist);
		},
		getRangeTargetElements : function (rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {
			return interpreter.getRangeTargetElements(rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);
		},
		generateCharOffsetRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {
			return generator.generateCharOffsetRangeComponent(rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist);
		},
		generateElementRangeComponent : function (rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist) {
			return generator.generateElementRangeComponent(rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist);
		},
		generateRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {
			return generator.generateRangeComponent(rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist);
		}
	};

	EPUBcfi.CFIInstructions = CFIInstructions;
	EPUBcfi.Parser = Parser;
	EPUBcfi.OutOfRangeError = OError;
	EPUBcfi.Interpreter = Interp;
	EPUBcfi.Generator = generator;

	EPUBcfi.NodeTypeError = NodeTypeError;
	EPUBcfi.OutOfRangeError = OutOfRangeError;
	EPUBcfi.TerminusError = TerminusError;
	EPUBcfi.CFIAssertionError = CFIAssertionError;

}) (typeof window === 'undefined' ? this : window);

/*
 * Bugsense JavaScript SDK v1.1.1
 * http://bugsense.com/
 *
 * Copyright 2013 Splunk Inc.
 *
 * Date: 2013-11-18
 */
var bugsense;

(function ( root, factory ) {
	if ( typeof define === 'function' && define.amd ) {
		// AMD. Register as an anonymous module.
		define(function () {
			// Also create a global in case some scripts
			// that are loaded still are looking for
			// a global even when an AMD loader is in use.
			return ( root.Bugsense = factory() );
		});
	} else {
		// Browser globals
		root.Bugsense = factory();
	}
}( this, function () {

	/**
	 * Simple extend() implementation
	 * @param  {Object} original The object to extend
	 * @param  {Object} extra    The properties to extend with
	 * @return {Object}          The extended original object
	 */
	var extend = function extend ( original, extra ) {
		return Object.keys( extra ).forEach( function ( key ) { original[ key ] = extra[ key ]; } );
	};

	// BEGIN - Extracted from Zepto
	var escape = encodeURIComponent;

	var isObject = function isObject ( instance ) {
		return instance instanceof Object;
	};

	var isArray = function isArray ( instance ) {
		return instance instanceof Array;
	};

	var isValidKeyValue = function isValidKeyValue ( instance ) {
		return ( typeof(instance) == 'string' || typeof(instance) == 'number' || typeof(instance) == 'boolean' );
	};

	/**
	 * Simple forEach, implements jQuery/Zepto api, sort of, and most likely breaks with arrays: LOL
	 * @param  {Object} obj      To be iterated
	 * @param  {Object} iterator Iterator function
	 */
	var forEach = function forEach ( obj, iterator ) {
		Array.prototype.forEach.call( Object.keys( obj ), function ( key ) {
			iterator( key, obj[ key ] );
		} );
	};

	var serialize = function serialize ( params, obj, traditional, scope ) {
		var array = isArray( obj );

		forEach( obj, function ( key, value ) {
			if ( scope ) { key = traditional ? scope : scope + '[' + (array ? '' : key) + ']'; }

			// handle data in serializeArray() format
			if ( !scope && array ) {
				params.add( value.name, value.value );
				// recurse into nested objects
			} else if ( traditional ? isArray( value ) : isObject( value ) ) {
				serialize( params, value, traditional, key );
			} else {
				params.add( key, value );
			}
		});
	};

	var param = function param ( obj, traditional ) {
		var params = [];
		params.add = function( k, v ){ this.push( escape( k ) + '=' + escape( v ) ); };
		serialize( params, obj, traditional );
		return params.join( '&' ).replace( /%20/g, '+' );
	};
	// END - Extracted from Zepto


	var guid_generator = function GUIDGenerator() {
		var S4 = function () {
			return Math.floor(
				Math.random() * 0x10000 /* 65536 */
			).toString(16);
		};

		return (
			S4() + S4() + "-" +
				S4() + "-" +
				S4() + "-" +
				S4() + "-" +
				S4() + S4() + S4()
			);
	}


	/**
	 * Constructor for the Bugsense instance
	 * @param {Object} config Overrides for the default config, use to specify api key
	 */
	var Bugsense = function ( config ) {
		extend(this.config, config);
		this.config.winjs = typeof (WinJS) !== 'undefined';
		this.extraData = {};
		this.breadcrumbs = [];

		bugsense = this;
		if ( typeof(this.config.context.onerror) !== 'undefined' && !this.config.disableOnError )
			this.config.context.onerror = bugsense.onerror;
		// WINJS
		if ( this.config.winjs ) {
			WinJS.Promise.onerror = bugsense.onpremiseerror;
			var p = Windows.ApplicationModel.Package.current.id.version;
			this.config.appversion = [p.major, p.minor, p.build, p.revision].join('.');
			this.send_cached_report_if_any();
			// Create unique device id
			var localSettings = Windows.Storage.ApplicationData.current.localSettings;
			var guid = localSettings['guid'];
			if (!guid) {
				guid = guid_generator();
				localSettings['guid'] = guid;
			}
			this.config.guid = guid;
		}
		// CORDOVA

		return this;
	};

	// Default config
	Bugsense.prototype.config = {
		apiKey     : 'FOOBAR',
		url        : 'https://www.bugsense.com/api/errors',
		//url      : 'https://csh-bugsense.fwd.wf/api/errors',
		pingUrl    : 'http://ticks2.bugsense.com/api/ticks',
		appversion : null,
		popup      : false, // unless WinJS
		callback   : null,
		context: window,
		winjs: null,
		message: null
	};

	/**
	 * Add extra data (meta data) to be sent upon uncaught exception
	 * @params {String} key      Key
	 * @params {String} value    Value
	 */
	Bugsense.prototype.addExtraData = function bugsenseAddExtraData ( key, value ) {
		if ( isValidKeyValue( key ) && isValidKeyValue( value ) ) {
			this.extraData[ key ] = value;
		}
	}

	/**
	 * Remove a key value pair from extra data
	 * @params {String} key      Key
	 */
	Bugsense.prototype.removeExtraData = function bugsenseRemoveExtraData ( key ) {
		delete this.extraData[ key ];
	}

	/**
	 * Clear extra data
	 */
	Bugsense.prototype.clearExtraData = function bugsenseClearExtraData () {
		this.extraData = {};
	}

	/**
	 * Leave a breadcrump
	 * @params {String} breadcrumb  Breadcrumb
	 */
	Bugsense.prototype.leaveBreadcrumb = function bugsenseLeaveBreadcrumb ( breadcrumb ) {
		if ( isValidKeyValue( breadcrumb ) ) {
			if ( this.breadcrumbs.length + 1 == 16 ) {
				this.breadcrumbs = this.breadcrumbs.slice( 1 );
			}
			this.breadcrumbs.push( breadcrumb );
		}
	}

	/**
	 * Clear breadcrumbs
	 */
	Bugsense.prototype.clearBreadcrumbs = function bugsenseClearBreadcrumbs () {
		this.breadcrumbs = []
	}

	/**
	 * Kill bugsense and the app. Force exit
	 */
	Bugsense.prototype._die = function bugsenseDie() {
		throw 'BugSense exited';
	}

	/**
	 * Handles the response from the Bugsense API endpoint
	 * @param  {Object} data       Bugsense response object
	 * @param  {String} textStatus Response http status code
	 * @param  {Object} XHR        XHR object
	 */
	Bugsense.prototype.successHandler = function bugsenseSuccessHandler(request) {
		// Die
		function _die () { throw 'BugSense exited'; }
		// TODO if WinJS show notifications to user
		if (request.target && request.target.readyState != 4) { return; }
		if (request.target && request.target.status != 200 && bugsense.config.winjs) {
			return false;
		}

		// some console.log implementations don't support multiple parameters, guess it's okay in this case to concatenate
		if ('console' in window) {
			console.log('logged 1 error to Bugsense, status: ' + request.target.responseText);
		}
		if (bugsense.config.winjs) {
			if (request.target.responseText !== undefined && request.target.responseText.indexOf('url') > 0) {
				var response = JSON.parse(request.target.responseText);
				// Display fix notification if set

				var md = new Windows.UI.Popups.MessageDialog(response.data.tickerText);
				var result, resultOptions = ['Update', 'Cancel'];
				var cmd;

				for (var i = 0; i < resultOptions.length; i++) {
					cmd = new Windows.UI.Popups.UICommand();
					cmd.label = resultOptions[i];
					// Style update
					cmd.invoked = function (c) {
						result = c.label;
					}
					md.commands.append(cmd);
				}

				md.showAsync().then(function (c) {
					if (c.label == 'Update') {
						var uri = Windows.Foundation.Uri(response.data.url);
						Windows.System.Launcher.launchUriAsync(uri);
					}
					return c.label;
				}).done(function complete() { window.bugsense._die(); });
				// Show popup message is set

			} else if (request.target.responseText.length > 0 && request.target.responseText.indexOf('url') < 0) { // NOT OPTIONS
				if (window.bugsense.config.message !== null) {
					var md = new Windows.UI.Popups.MessageDialog(window.bugsense.config.message);
					var result, resultOptions = ['OK'];
					var cmd;

					for (var i = 0; i < resultOptions.length; i++) {
						cmd = new Windows.UI.Popups.UICommand();
						cmd.label = resultOptions[i];
						cmd.invoked = function (c) {
							result = c.label;
						}
						md.commands.append(cmd);
					}

					md.showAsync().then(function (c) {
						return c.label;
					}).done(function complete() { window.bugsense._die(); });
				} else {
					// Just die!
					window.bugsense._die();
				}
			}
		}

	};

	/**
	 * Returns the Bugsense api url, with a cacheBuster argument
	 * @return {String} Bugsense API URL endpoint
	 */
	Bugsense.prototype.getPostURL = function bugsenseGetPostURL () {
		return Bugsense.prototype.config.url + '?cacheBuster=' + ( new Date() ).getTime();
	};

	/**
	 * Parses a raw Error object
	 * @param  {Object} error A raw Error object - e.g.: as sent from try/catch
	 * @return {Object}       An object containing the parsed data as its properties
	 */
	Bugsense.prototype.parseError = function bugsenseParseError ( error ) {
		var parsedError = {}
		// Firefox
		if ( navigator.userAgent.toLowerCase().indexOf('firefox') > -1 ){
			parsedError = {
				message: error.message,
				url: window.location.href,
				line: error.lineNumber,
				stack: error.stack,
				type: error.name
			}
			// Unhandled WinJS
		} else if ( this.config.winjs === true && typeof( error.stack ) === 'undefined' ) {
			parsedError = {
				message: error.detail.errorMessage,
				url: error.detail.errorUrl,
				line: error.detail.errorLine,
				stack: ( error.detail.stack === undefined ) ? error.detail.errorMessage : error.detail.stack,
				type: error.detail.errorCode
			};
			// Handled WinJS
		} else if (this.config.winjs === true && typeof( error.stack ) !== 'undefined') {
			var s = error.stack;
			var tmp = s.substr(s.indexOf('(') + 1, s.indexOf(')') - s.indexOf('(') - 1).split(':');
			parsedError = {
				message: error.message,
				url: tmp[0] + ':' + tmp[1],
				line:tmp[2] ,
				stack: error.stack,
				type: error.stack.split(':')[0],
				handled: true
			};
			// Webkit
		} else {
			// If .stack is not available
			try {
				var where_parts = error.stack.split( '\n' ).slice(1)[0].match( /\s+at\s.*(\/.*\..*|<anonymous>:\d*:\d*)/ );
			} catch ( error ) {
				error.stack = error.message;
			}
			parsedError = {
				message: [ error.name, error.message ].join( ': ' ),
				url: where_parts ? where_parts[ 1 ].split( ':' )[ 0 ].replace("/","") : '',
				line: where_parts ? where_parts[ 1 ].split( ':' )[ 1 ] : '',
				stack: error.stack,
				type: error.name
			};
		}

		if ( parsedError.stack == null || ( typeof( parsedError.stack ) == 'string' && parsedError.stack.length == 0 ) ) {
			parsedError.stack = parsedError.message;
		}

		return parsedError;
	};

	/**
	 * Generates an object containing the exception data, compliant with Bugsense's API
	 * @param  {String} exception   The error message ( also accepts Error Object, will be normalized )
	 *                              e.g.: "Uncaught ReferenceError: ben is not defined"
	 * @param  {String} url         The originating url
	 *                              e.g.: "http://lmjabreu.local:8002/assets/js/main.js"
	 * @param  {Number} line        The line number
	 *                              e.g.: "12"
	 * @param  {Object} custom_Data An object containing extra debugging data
	 * @return {Object}           Bugsense API-compliant exception object
	 */
	Bugsense.prototype.generateExceptionData = function bugsenseGenerateExceptionData ( message, url, line, stack, custom_data ) {
		if ( typeof( message ) != "string" ) {
			message = message.toString()
		}

		var s = window.navigator.userAgent;
		var connection_type = 'unknown';
		if (this.config.winjs) {
			try {
				connection_type = Windows.Networking.Connectivity.NetworkInformation.getInternetConnectionProfile().profileName;
			} catch (exception) {
				connection_type = 'Offline';
			}
		} else if ( typeof window.navigator.network !== 'undefined' ) {
			connection_type = window.navigator.network.connection.type;
		}

		var data = {
			// information about the bugsense client
			client: {
				// Obligatory
				'name'    : 'bugsense-js',
				// Optional
				'version' : '1.1'
			},
			// Optional
			// details & custom data about the exception including url, request, response,…
			request: {
				'custom_data' : custom_data
			},
			// basics about the exception
			exception: {
				// Obligatory
				'message'     : message,
				'where'       : [ url, line ].join( ':' ),
				'klass'       : message.split( ':' )[ 0 ],
				'backtrace'   : ( typeof(stack) === 'undefined' ) ? message : stack,
				'breadcrumbs': this.breadcrumbs
			},
			// basic data ( required )
			application_environment: {
				// Obligatory
				'phone'              : window.navigator.platform,
				'appver'             : ( this.config.appversion || 'unknown' ),
				'appname'            : ( this.config.appname || 'unknown' ),
				'osver'              : ( typeof window.device !== 'undefined' ) ? window.device.version : s.substr(s.indexOf('; ')+2,s.length).replace(')',';').split(';')[0] || 'unknown' ,
				// Optional
				'connection_type'    : connection_type,
				'user_agent'         : window.navigator.userAgent,
				'cordova'            : ( typeof window.device !== 'undefined' ) ? window.device.cordova : 'unknown',
				'device_name'        : ( typeof window.device !== 'undefined' ) ? window.device.name : 'unknown',
				'log_data'           : this.extraData
			}
		};

		if (this.config.winjs) {
			// Extra vars for Windows apps
			data.application_environment.cpuClass = window.navigator.cpuClass;
			data.application_environment.osver = window.navigator.userAgent.split(';')[2];
			data.application_environment.languages = window.navigator.systemLanguage;
			data.application_environment.locale = window.navigator.userLanguage;
			data.application_environment.is_trial = Windows.ApplicationModel.Store.CurrentApp.licenseInformation.isTrial;
			data.application_environment.is_active = Windows.ApplicationModel.Store.CurrentApp.licenseInformation.isActive;
			data.application_environment.uid = this.config.guid;
			if (typeof (custom_data) !== 'undefined') {
				if ( typeof(custom_data.handled) !== 'undefined' ){
					data.exception.handled = 0;
				}
			}
		}

		return data;
	};

	/**
	 * Returns true for Error objects
	 * @param  {Object} exception The object to test
	 * @return {Boolean}           True for Error objects - [object Error]
	 */
	Bugsense.prototype.testException = function bugsenseTestException(exception) {
		// unhandled winjs exceptions
		if (this.config.winjs === true && typeof(exception.detail) !== 'undefined')
			return exception.type === "error";
		// catches handled winjs exceptions as well
		return Object.prototype.toString.call(exception) === '[object Error]';
	};

	/**
	 * Returns true if it is an exeption throwed by BugSense
	 * @param {Object} exception
	 */
	Bugsense.prototype.isBugsenseException = function bugsenseIsBugsenseException(exception) {
		return this.config.winjs && this.testException(exception) && exception.detail.errorMessage === "BugSense exited";
	}

	/**
	 * Notify Bugsense about an exception
	 * @param  {String} exception   The error message ( also accepts Error Object, will be normalized )
	 * @param  {String} url         The originating url
	 * @param  {String} line        The line number
	 * @param  {Object} custom_data Custom data to send over to Bugsense
	 */
	Bugsense.prototype.notify = function bugsenseNotify(exception, url, line, column, custom_data) {
		var stack;
		// Prints exception stack to console before the exception is handled by Bugsense
		if (typeof(column) === 'object') {
			custom_data = column;
		}
		if (window.console && window.console.error) {
			console.error(exception, url+':'+line);
		}
		// Handle cases where only Error object and custom data are sent - url will be the custom_data
		if ( typeof(url) === 'object' && this.testException( exception ) ) { custom_data = url; url = undefined; }

		// If the exception is the full Error object, extract what we want from it
		if ( this.testException( exception ) ) {
			var parsedError = this.parseError( exception );

			message = [ parsedError.type, parsedError.message ].join( ':' );
			url = parsedError.url;
			line = parsedError.line;
			stack = parsedError.stack;
			if (typeof (parsedError.handled) !== 'undefined') {
				if (typeof (custom_data) !== 'object') custom_data = {};
				custom_data.handled = 0;
			}
		} else {
			message = exception;
		}

		var data = this.generateExceptionData( message, url, line, stack, custom_data );

		// Send the data over to Bugsense
		var xmlhttp = new XMLHttpRequest();
		xmlhttp.open( 'POST', this.getPostURL(), true );
		xmlhttp.setRequestHeader( 'X-BugSense-Api-Key', this.config.apiKey );
		xmlhttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
		xmlhttp.onerror = function (a) {
			if (bugsense.config.winjs) {
				WinJS.Application.local.writeText('CachedCrashReport', JSON.stringify(data)).done(
					function complete() { console.log('written'); window.bugsense._die() }
				);
			}
		}
		if (!(custom_data instanceof Object && custom_data.handled == 0))
			xmlhttp.onreadystatechange = this.successHandler;

		xmlhttp.send(param({ data: JSON.stringify(data) }));

		return true;
	};

	/**
	 * Send cashed crash report
	 */
	Bugsense.prototype.send_cached_report_if_any = function bugsenseSendCachedReport() {
		var local = WinJS.Application.local;
		local.exists('CachedCrashReport').then(function (exists) {
			if (exists) {
				local.readText('CachedCrashReport').then(function (strdata) {
					var data = JSON.parse(strdata);
					// Send the data over to Bugsense
					var xmlhttp = new XMLHttpRequest();
					xmlhttp.open('POST', window.bugsense.getPostURL(), true);
					xmlhttp.setRequestHeader('X-BugSense-Api-Key', window.bugsense.config.apiKey);
					xmlhttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
					xmlhttp.onreadystatechange = function (request) {
						if (request.target && request.target.readyState == 4) {
							WinJS.Application.local.remove('CachedCrashReport');
							return;
						}
					};
					xmlhttp.send(param({ data: JSON.stringify(data) }));
				}).done();
			}
		}).done();
	};

	/**
	 * Closure function for unhandled exceptions
	 *
	 */
	Bugsense.prototype.onerror = function bugsenseonerror(exception, url, line, column, custom_data) {
		// Ignore bugsense raised exception
		if (window.bugsense.isBugsenseException(exception))
			return false;
		return window.bugsense.notify(exception, url, line, column, custom_data);
	};

	Bugsense.prototype.onpromiseerror = function bugsenseonpromiseerror(event) {
		// Ignore bugsense raised exception
		if (window.bugsense.isBugsenseException(exception))
			return false;
		return window.bugsense.notify(event.detail.exception, event.detail.promise);
	};

	return Bugsense;

}));

(function(root, factory){
	'use strict';

	// CommonJS
	if (typeof exports === 'object' && module){
		module.exports = factory();
		// AMD
	} else if (typeof define === 'function' && define.amd){
		define(factory);
	}

	// Browser
	root.FilterJS = factory();

})( (typeof window === 'object' && window ) || this, function(){
	'use strict';

	var FilterJS = function(){
		this.hooks = {};
		this.version = '0.0.1';
	};

	FilterJS.prototype = {
		/**
		 * Returns the callbacks assigned to a specific name.
		 * */
		getHooks: function(name){
			if(!this.hooks.hasOwnProperty(name) || !(this.hooks[name] instanceof Array)){
				this.hooks[name] = [];
			}
			return this.hooks[name];
		},
		/**
		 * Adds a callback for a specific filter. It can accept an array of callbacks.
		 * */
		addFilter: function(name, cb){
			var hooks = this.getHooks(name);

			if(cb instanceof Array){
				for(var i = 0, l = cb.length; i < l; i++){
					hooks.push(cb[i]);
				}
			} else {
				hooks.push(cb);
			}
		},
		/**
		 * Removes the specified callback from the specified filter. Can remove an array of callbacks.
		 * */
		removeFilter: function(name, cb){
			var listeners = this.getHooks(name), index = -1;

			if(cb instanceof Array){
				for(var i = 0, l = cb.length; i < l; i++){
					index = listeners.indexOf(cb[i]);
					if(index !== -1){
						listeners.splice(index, 1);
					}
				}
			} else {
				index = listeners.indexOf(cb);
				if(index !== -1){
					listeners.splice(index, 1);
				}
			}
		},
		/**
		 * Removes all hooks attached to a filter.
		 * */
		removeAllFilters: function(name){
			var hooks = this.getHooks(name);
			for(var i = 0, l = hooks.length; i < l; i++){
				this.removeFilter(name, hooks[i]);
			}
		},
		/**
		 * Applies the hooks of a given filter.
		 * */
		applyFilters: function(name, data){
			var result = data;
			var hooks = this.getHooks(name);
			for(var i = 0, l = hooks.length; i < l; i++){
				var hook = hooks[i];
				if(typeof hook === 'function'){
					result = hook(result);
				}
			}
			return result;
		}
	};

	return FilterJS;
});
'use strict';

// Sub module for managing a book's meta-information (url, title, spine, isbn)

var Reader = (function (r) {

	var defaultData = {
		// This version number identifies the data format:
		version: '2.0.0',
		spine: [],
		toc: [],
		title: '',
		author: '',
		opfPath: '',
		contentPathPrefix: '',
		opfDoc: null,
		totalWordCount: 0,
		totalImageCount: 0,
		sample: false
	};

	var filesCache = {};

	// Retrieves the spine data from the OPF document:
	// http://www.idpf.org/epub/20/spec/OPF_2.0.1_draft.htm#Section2.4
	function getSpineFromOPF(opfDoc, pathPrefix) {
		return $.map($(opfDoc.querySelector('spine')).children(), function (itemref) {
			var id = itemref.getAttribute('idref'),
					item = opfDoc.getElementById(id);
			return {
				itemId: id,
				href: pathPrefix + item.getAttribute('href'),
				// The default is "yes", so unlike it's "no", the spine item is linear:
				linear: itemref.getAttribute('linear') === 'no' ? false : true,
				mediaType: item.getAttribute('media-type')
			};
		});
	}

	// Retrieves the TOC from a given navMap entry point (recursive function):
	function getTOCFromNavMap(navMap, pathPrefix) {
		return $.map($(navMap).children('navPoint'), function (navPoint) {
			var $navPoint = $(navPoint),
				data = {
					// active: true, // false if HTML file is not available, e.g. in samples
					href: pathPrefix + $navPoint.children('content').attr('src'),
					label: $navPoint.children('navLabel').children('text').text()
				},
				children = getTOCFromNavMap(navPoint, pathPrefix);
			if (children.length) {
				data.children = children;
			}
			return data;
		});
	}

	// Retrieves the TOC from a given collection of list items (recursive function):
	function getTOCFromNavList(navList, pathPrefix) {
		return $.map(navList, function (listItem) {
			var $listItem = $(listItem),
				data = {
					// active: true, // false if HTML file is not available, e.g. in samples
					href: pathPrefix + $listItem.children('a').attr('href'),
					label: $listItem.children('a,span').text()
				},
				children = getTOCFromNavList($listItem.children('ol').children('li'), pathPrefix);
			if (children.length) {
				data.children = children;
			}
			return data;
		});
	}

	// Get a file from the server:
	function loadFile(resource, type) {
		var promise = filesCache[resource],
				defer;
		if (promise !== undefined) {
			// Delete entries from the files cache as soon as they have been used.
			// This prevents storing too much data in memory:
			delete filesCache[resource];
			return promise;
		}
		defer = $.Deferred();
		$.ajax({
			url: r.DOCROOT + '/' + resource,
			dataType: type ? type : 'text'
		}).then(defer.resolve, function (err) {
			defer.reject($.extend({}, r.Event.ERR_MISSING_FILE, {details: err.responseText}));
		});
		return defer.promise();
	}

	// Load a file and store the promise in an in-memory store:
	function preloadFile(resource, type) {
		var promise = loadFile(resource, type);
		filesCache[resource] = promise;
		return promise;
	}

	// Retrieve the opfPath from the root file:
	function loadOpfPath(data) {
		return loadFile(r.ROOTFILE_INFO_PATH, 'xml').then(function rootFileLoaded(rootDoc) {
			data.opfPath = rootDoc.querySelector('rootfile').getAttribute('full-path');
			return data;
		});
	}

	// Returns a document for a valid XML string:
	function parseXML(content) {
		return (new DOMParser()).parseFromString(content, 'text/xml');
	}

	// Load opfFile and store opfDoc and contentPathPrefix in the given data object:
	function loadOpfData(data) {
		if (data.opfPath) {
			var pathPrefix = data.opfPath.split('/').slice(0, -1).join('/');
			// Add a trailing slash if we have a path prefix:
			data.contentPathPrefix = pathPrefix && pathPrefix + '/';
		}
		if (data.opf) {
			// OPF data is provided via XML string
			data.opfDoc = parseXML(data.opf);
			return $.Deferred().resolve(data).promise();
		}
		return loadFile(data.opfPath).then(function opfFileLoaded(content) {
			data.opf = content;
			data.opfDoc = parseXML(content);
			return data;
		});
	}

	// Function to load the TOC data from the EPUB2 NCX file or the EPUB3 navigation document:
	function loadTOCData(data) {
		var opfDoc = data.opfDoc,
				navItem = opfDoc.querySelector('manifest').querySelector('item[properties="nav"]'),
				navHref = navItem && navItem.getAttribute('href'),
				ncxId = !navHref && opfDoc.querySelector('spine').getAttribute('toc'),
				ncxHref = ncxId && opfDoc.getElementById(ncxId).getAttribute('href');
		if (navHref) {
			// EPUB v3 navigation document:
			// http://www.idpf.org/epub/30/spec/epub30-contentdocs.html#sec-xhtml-nav
			return loadFile(data.contentPathPrefix + navHref).then(function navDocLoaded(navDoc) {
				var navList = $(navDoc).filter('nav[epub\\:type="toc"]').children('ol').children('li');
				data.toc = getTOCFromNavList(navList, data.contentPathPrefix);
				return data;
			});
		}
		// EPUB2 NCX file:
		// http://www.idpf.org/epub/20/spec/OPF_2.0.1_draft.htm#Section2.4.1
		return loadFile(data.contentPathPrefix + ncxHref, 'xml').then(function ncxFileLoaded(ncxDoc) {
			data.toc = getTOCFromNavMap(ncxDoc.querySelector('navMap'), data.contentPathPrefix);
			return data;
		});
	}

	// Load book meta data if book-info.json is not available:
	function loadBookMetaData(args) {
		return loadOpfPath({})
			.then(loadOpfData)
			.then(loadTOCData)
			.then(function (data) {
				// Retrieve meta data from OPF document:
				// http://www.idpf.org/epub/20/spec/OPF_2.0.1_draft.htm#Section2.2
				var opfDoc = data.opfDoc,
						metadata = opfDoc.querySelector('metadata'),
						titleElement = metadata.querySelector('title'),
						authorElement = metadata.querySelector('creator');
				return $.extend(data, {
					title: titleElement && titleElement.textContent,
					author: authorElement && authorElement.textContent,
					spine: getSpineFromOPF(opfDoc, data.contentPathPrefix)
				}, args);
			});
	}

	// Load book meta data from book-info.json:
	function loadBookInfo(args) {
		// Check if the book info is available (explicit type check as the property might be undefined):
		if (args.hasBookInfo === false) {
			return $.Deferred().reject().promise();
		}
		return loadFile(r.BOOK_INFO_PATH, 'json')
			.then(loadOpfData)
			.then(function (data) {
				return $.extend(data, args);
			});
	}

	// Count the number of words in the given HTML string:
	function countWords(str) {
		str = str
			// Replace the title element, as we don't count its contents:
			.replace(/<title>[^<]+<\/title>/i, '')
			// Replace all HTML elements with single spaces:
			.replace(/(<[^>]+>)/gi, ' ');
		// Convert all HTML entities to their textual representation,
		// so that whitespace entities are not counted as text:
		str = $('<p>').html(str).text();
		// Calculate the word matches:
		var match = str.match(/\s+\S+/g);
		return match ? match.length : 0;
	}

	// Count the number of images (and SVG elements) in the given HTML string:
	function countImages(str) {
		var result = str.match(/(<img)|(<svg)/gi);
		return result ? result.length : 0;
	}

	// Strip any HTML comments from the given HTML string:
	function stripHTMLComments(str) {
		return str.replace(/<!--.*?-->/g, '');
	}

	// Function to handle a given number of parallel requests:
	function parallelRequestsHandler(list, request) {
		var defer = $.Deferred(),
				count = list.length,
				index = 0,
				maxRequests = r.preferences.maxParallelRequests.value,
				pendingRequests = 0,
				handleResponse = function () {
					pendingRequests--;
					initRequests();
				},
				sendRequests = function () {
					while (index < count && pendingRequests < maxRequests) {
						pendingRequests++;
						request(list[index++]).always(handleResponse);
					}
				},
				initRequests = function () {
					if (index === count) {
						if (!pendingRequests) {
							defer.resolve(list);
						}
					} else {
						sendRequests();
					}
				};
		initRequests();
		return defer.promise();
	}

	// Function to parse a chapter in the spine to calculate word- and image- count:
	function parseChapter(spineItem) {
		// Check if the spine item is available (explicit type check as the active property might be undefined):
		if (spineItem.active === false) {
			// Given file is not available in the EPUB
			return $.Deferred().reject().promise();
		}
		return loadFile(spineItem.href)
			.done(function (result) {
				result = stripHTMLComments(result);
				spineItem.imageCount = countImages(result);
				if (spineItem.wordCount === undefined) {
					spineItem.wordCount = countWords(result);
				}
				spineItem.active = true;
			})
			.fail(function () {
				// Given file is not available in the EPUB:
				spineItem.active = false;
			});
	}

	// Function to parse each chapter in the spine to calculate word- and image- count:
	function parseChapters(data) {
		return parallelRequestsHandler(data.spine, parseChapter).then(function () {
			return data;
		});
	}

	// Wrapper function to load book meta data from book-info.json or EPUB meta files:
	function loadBookData(args) {
		var defer = $.Deferred();
		// Notify the client that loading of the book meta data has been started:
		defer.notify({type: 'meta.loading'});
		if (args.spine) {
			// Book data is provided via arguments, so we only load the opfData:
			loadOpfData($.extend({}, args))
				.then(defer.resolve, defer.reject);
			return defer.promise();
		} else {
			// Try loading book-info.json:
			loadBookInfo(args).then(
				defer.resolve,
				function () {
					args.hasBookInfo = false;
					// book-info.json not available, load meta data manually:
					loadBookMetaData(args)
						.then(defer.resolve, defer.reject);
				}
			);
			// Book data is not provided via arguments
			return defer.promise().then(function (data) {
				// loadProgressData === 1 -> load progress data on Book load
				if (r.preferences.loadProgressData.value === 1) {
					// Parse the chapters for the word/image count:
					return parseChapters(data);
				}
				return data;
			});
		}
	}

	// Function to count the total word- and image- count for the given book data:
	function calculateTotals(book) {
		var spine = book.spine,
				wordCount = 0,
				imageCount = 0,
				i = 0,
				item;
		while ((item = spine[i++])) {
			// Check if the spine item is available (explicit type check as the active property might be undefined):
			if (item.active !== false) {
				wordCount += item.wordCount;
				imageCount += item.imageCount;
			}
		}
		book.totalWordCount = wordCount;
		book.totalImageCount = imageCount;
	}

	// Function to retrieve the associated TOC item for a given href and optional currentPage.
	// The search starts from the given TOC item to simplify recursion:
	function parseTOCItem(item, href, currentPage) {
		var children = item.children,
			result,
			i,
			childItem,
			anchorId,
			anchorPage;
		if (item.href && item.href.indexOf(href) === 0) {
			if (!currentPage) {
				return item;
			}
			result = item;
		}
		if (children) {
			for (i = 0; i < children.length; i++) {
				childItem = parseTOCItem(children[i], href, currentPage);
				if (childItem) {
					if (result) {
						anchorId = childItem.href.split('#')[1];
						if (!anchorId) {
							continue;
						}
						anchorPage = r.returnPageElement('#' + anchorId);
						if (anchorPage === -1) {
							continue;
						}
						if (anchorPage > currentPage) {
							break;
						}
					}
					result = childItem;
				}
			}
		}
		return result;
	}

	// Adds labels from TOC and progress information to the spine:
	function addLabelAndProgressToSpine(book) {
		var spine = book.spine,
				totalCount = book.getTotalWordCount(),
				currentCount = 0,
				i = 0,
				spineItem,
				tocItem;
		while ((spineItem = spine[i++])) {
			if (spineItem.label === undefined) {
				tocItem = book.getTOCItem(spineItem.href);
				if (tocItem) {
					spineItem.label = tocItem.label;
				}
			}
			// Check if the spine item is available (explicit type check as the active property might be undefined):
			if (spineItem.active !== false) {
				// Add +1 to the current word count of the previous chapters
				// to identify the progress for the first word of the chapter:
				spineItem.progress = (currentCount + 1) / totalCount * 100;
				currentCount += book.getWordCount(spineItem);
			}
		}
	}

	// Initialize the book with the given data:
	function initializeBookData(data) {
		var book = r.Book;
		$.extend(book, data);
		calculateTotals(book);
		addLabelAndProgressToSpine(book);
		r.Navigation.setNumberOfChapters(book.spine.length);
		return book;
	}

	r.Book = {
		// Method to load a file from the book resources:
		loadFile: loadFile,
		// Method to preload a file for faster subsequent access:
		preloadFile: preloadFile,
		// Load the book information.
		// Uses the given arguments and loads any missing data:
		load: function (args) {
			this.reset();
			return loadBookData(args || {}).then(initializeBookData);
		},
		// Load the spine progress data (word- and image count):
		loadProgressData: function () {
			return parseChapters(this).then(initializeBookData);
		},
		// Reset the module to default values:
		reset: function () {
			$.extend(this, defaultData);
		},
		// Retrieve the associated TOC item for a given href and optional currentPage:
		getTOCItem: function (href, currentPage) {
			return parseTOCItem({children: this.toc}, href, currentPage);
		},
		// Get the spine index for the given URL:
		getSpineIndex: function (url) {
			var spine = this.spine,
					i = 0,
					item;
			while ((item = spine[i])) {
				// Check if the spine item is available (explicit type check as the active property might be undefined):
				if (item.active !== false && item.href.indexOf(url.split('#')[0]) === 0) {
					return i;
				}
				i++;
			}
			return -1;
		},
		// Retrieve the total word count of a book (takes image count into account):
		getTotalWordCount: function () {
			return this.totalWordCount + (this.totalImageCount || 0) * r.preferences.imageWordCount.value;
		},
		// Retrieve the word count of a chapter (takes image count into account):
		getWordCount: function (spineItem) {
			return spineItem.wordCount + (spineItem.imageCount || 0) * r.preferences.imageWordCount.value;
		},
		// Export the book data that can be converted to JSON:
		getData: function () {
			var data = {},
					prop,
					value;
			for (prop in this) {
				value = this[prop];
				if (this.hasOwnProperty(prop) && typeof value !== 'function' && !(value instanceof Node)) {
					data[prop] = value;
				}
			}
			return data;
		}
	};

	// Initialize the Reader with default (empty) book data:
	r.Book.reset();

	return r;
}(Reader || {}));

'use strict';

/* jshint unused: true */
/* exported Reader */
/* globals $ */

var Reader = (function (r) {
	// This is a private array of bookmarks for the current book. The data is organised based on chapters.
	// Ex: `_bookmarks[1]` contains an array of bookmarks from the first chapter.
	var _bookmarks = [];

	// The **Bookmarks** object exposes methods to allow the user to manage their bookmarks.
	//
	// * [`getBookmarks`](#getBookmarks)
	// * [`setBookmarks`](#setBookmarks)
	// * [`removeBookmark`](#removeBookmark)
	// * `goToBookmark`
	// * `reset`
	// * [`display`](#display)
	r.Bookmarks = {
		ATTRIBUTE: 'data-bookmark',
		// <a name="getBookmarks"></a> Public getter function.
		getBookmarks: function(){
			return _bookmarks;
		},
		getVisibleBookmarks: function(){
			var bookmarks = [];
			$('[data-bookmark][data-cfi]', r.$iframe.contents()).each(function(index, el){
				if(r.returnPageElement(el) === r.Navigation.getPage()){
					bookmarks.push($(el).attr('data-cfi'));
				}
			});
			return bookmarks;
		},
		// <a name="setBookmarks"></a>This function will set the bookmarks based on the chapter they appear in.
		// `val` is an array of cfi-s representing the current book's bookmarks.
		setBookmarks: function(val, noMarker){
			if($.isArray(val)){
				$.each(_bookmarks, function(i, el){
					if($.isArray(el)){
						$.each(el, function(index, cfi){
							if(cfi){
								r.Bookmarks.removeBookmark(cfi);
							}
						});
					}
				});
				_bookmarks = [];
				$.each(val, function(i, element){
					r.Bookmarks.setBookmark(element, noMarker);
				});
			}
		},

		// <a name="setBookmark"></a>This function saves a bookmark in the appropriate location, based on the chapter it appears in, and returns the cfi object associated with it.
		//
		// * `cfi` (optional) the cfi to save as a bookmark, otherwise the current page's cfi will be used.
		// * `noMarker` (optional) flag to indicate the bookmark does not require a marker inserted into the DOM.
		setBookmark: function(cfi, noMarker){
			var cfiObj = null;
			if(typeof(cfi) === 'undefined'){
				cfiObj = r.Navigation.getCurrentCFI();
				if($.type(cfiObj) === 'object'){
					cfi = cfiObj.CFI;
				} else {
					r.Notify.error($.extend({}, r.Event.ERR_CFI_GENERATION, {details: cfiObj, call: 'setBookmark'}));
					return false;
				}
			}

			var index = r.CFI.getChapterFromCFI(cfi);
			if(index !== -1){
				if(!$.isArray(_bookmarks[index])){
					_bookmarks[index] = [];
				}
				if($.inArray(cfi, _bookmarks[index]) === -1){
					_bookmarks[index].push(cfi);
					if(!noMarker && index === r.Navigation.getChapter()){
						r.CFI.setBookmarkCFI(cfi);
						r.Bookmarks.display();
					}
					return cfiObj !== null ? JSON.stringify(cfiObj) : cfi;
				}
			}  else {
				// cfi not recognised in book
				r.Notify.error($.extend({}, r.Event.ERR_BOOKMARK_ADD, {details: cfi, call: 'setBookmark'}));
				return false;
			}
			// bookmark exists
			r.Notify.error($.extend({}, r.Event.ERR_BOOKMARK_EXISTS, {details: cfi, call: 'setBookmark'}));
			return false;
		},
		// <a name="removeBookmark"></a>This function will remove a bookmark from the book and any associated DOM elements.
		// * `cfi` (required) the CFI of the bookmark to remove.
		removeBookmark: function(cfi){
			var chapter = r.CFI.getChapterFromCFI(cfi);
			if(chapter !== -1){
				var index = $.inArray(cfi, _bookmarks[chapter]);
				if($.isArray(_bookmarks[chapter]) && index !== -1){
					_bookmarks[chapter].splice(index, 1);

					var $marker = $('[data-bookmark][data-cfi="' + cfi + '"]', r.$iframe.contents());
					if($marker.length){
						if($marker.hasClass('cpr-marker')){
							var $parent = $marker.parent();
							$marker.remove();

							// this restates the DOM to the previous structure
							// todo do not alter the DOM in the first place
							$parent[0].normalize();
						} else {
							$marker.removeAttr('data-bookmark');
						}
					}

					r.Bookmarks.display();
					return true;
				}
			}
			// cannot remove bookmark
			r.Notify.error($.extend({}, r.Event.ERR_BOOKMARK_REMOVE, {details: cfi, call: 'removeBookmark'}));
			return false;
		},
		goToBookmark: function(cfi){
			return r.CFI.goToCFI(cfi);
		},
		reset: function(){
			_bookmarks = [];
		},
		// <a name="display"></a>This function refreshes the bookmark UI. If a bookmark is visible on the current page, it will display the bookmark UI. Ignores mobile readers.
		display: function(){
			var isVisible = false;
			$('[data-bookmark]', r.$iframe.contents()).each(function(index, el){
				isVisible = r.returnPageElement(el) === r.Navigation.getPage();
				if (isVisible) {
					return false;
				}
			});
			if (r.mobile) {
				return isVisible;
			}
			if(isVisible){
				$('#cpr-bookmark-ui', r.$iframe.contents()).show();
				return isVisible;
			} else {
				$('#cpr-bookmark-ui', r.$iframe.contents()).hide();
			}
			return false;
		}
	};

	// This is a private array of highlights for the current book. The data is organised based on chapters.
	// Ex: `_highlights[1]` contains an array of bookmarks from the first chapter.
	var _highlights = [];

	r.Highlights = {
		ATTRIBUTE: 'data-highlight',
		getHighlights: function(){
			return _highlights;
		},
		// <a name="setHighlights"></a>This function will set the highlights based on the chapter they appear in.
		// `val` is an array of cfi-s representing the current book's bookmarks.
		setHighlights: function(val){
			if($.isArray(val)){
				$.each(_highlights, function(i, el){
					if($.isArray(el)){
						$.each(el, function(index, cfi){
							if(cfi){
								r.Highlights.removeHighlight(cfi);
							}
						});
					}
				});
				_highlights = [];
				$.each(val, function(i, element){
					r.Highlights.setHighlight(element);
				});
			}
		},
		// <a name="setHighlight"></a>This function saves a highlight in the appropriate location, based on the chapter it appears in, and returns the cfi associated with it.
		//
		// * `cfi` (optional) the cfi to save as a highlight, otherwise the current selection's cfi will be used. If no cfi exists and no selection is set, an exception is thrown.
		setHighlight: function(cfi){

			var preview = '';

			if(!cfi){
				// if cfi is not preset, we assume the current selection needs to be highlighted
				var selection = r.$iframe.contents()[0].getSelection();
				if(selection.rangeCount > 0 && !selection.isCollapsed){
					preview = selection.toString();
					try{
						cfi = r.Epub.generateRangeCFI(selection.getRangeAt(0));
					} catch(e){
						r.Notify.error($.extend({}, r.Event.ERR_HIGHLIGHT_ADD, {call: 'setHighlight', details: e}));
						return false;
					}
					// clear selection
					if (selection.empty) {  // Chrome
						selection.empty();
					} else if (selection.removeAllRanges) {  // Firefox
						selection.removeAllRanges();
					}
				} else {
					// no selected text
					r.Notify.error($.extend({}, r.Event.ERR_HIGHLIGHT_ADD, {call: 'setHighlight'}));
					return false;
				}
			}

			var chapter = r.CFI.getChapterFromCFI(cfi);
			if(chapter !== -1){
				if(!$.isArray(_highlights[chapter])){
					_highlights[chapter] = [];
				}
				if($.inArray(cfi, _highlights[chapter]) === -1){
					_highlights[chapter].push(cfi);
					if(chapter === r.Navigation.getChapter()){
						r.CFI.setHighlightCFI(cfi);
						r.Highlights.display();
					}

					var item = r.Book.getTOCItem(r.Book.spine[chapter].href, r.Navigation.getPage()),
						data = {
							CFI: cfi,
							preview: preview,
							chapter: item && item.label,
							href: item && item.href
						};

					r.Notify.event($.extend({}, r.Event.HIGHLIGHT_ADDED, {call: 'setHighlight'}, data));

					return JSON.stringify(data);
				}
			} else {
				// cfi not recognised in book
				r.Notify.error($.extend({}, r.Event.ERR_HIGHLIGHT_ADD, {details: cfi, call: 'setHighlight'}));
				return false;
			}
			// highlight already exists
			r.Notify.error($.extend({}, r.Event.ERR_HIGHLIGHT_EXISTS, {details: cfi, call: 'setHighlight'}));
			return false;
		},
		removeHighlight: function(cfi){
			var chapter = r.CFI.getChapterFromCFI(cfi);
			if(chapter !== -1){
				var index = $.inArray(cfi, _highlights[chapter]);
				if($.isArray(_highlights[chapter]) && index !== -1){
					_highlights[chapter].splice(index, 1);
					$('['+r.Highlights.ATTRIBUTE+'][data-cfi="' + cfi + '"]', r.$iframe.contents()).remove();
					r.Highlights.display();
					return true;
				}
			}
			// cannot remove bookmark
			r.Notify.error($.extend({}, r.Event.ERR_HIGHLIGHT_REMOVE, {details: cfi, call: 'removeHighlight'}));
			return false;
		},
		display: function(){
			var isVisible = false;

			// resize highlights
			$('['+r.Highlights.ATTRIBUTE+']', r.$iframe.contents()).remove();
			// Add all highlights for this chapter
			var highlights = r.Highlights.getHighlights()[r.Navigation.getChapter()];
			if(highlights){
				$.each(highlights, function(index, highlight){
					// Ignore bookmarks not part of the current chapter part:
					if (highlight && r.Navigation.isCFIInCurrentChapterPart(highlight)) {
						r.CFI.setHighlightCFI(highlight);
					}
				});
			}

			$('['+r.Highlights.ATTRIBUTE+']', r.$iframe.contents()).each(function(index, el){
				isVisible = r.returnPageElement(el) === r.Navigation.getPage();
				if (isVisible) {
					return false;
				}
			});
			return isVisible;
		},
		getVisibleHighlights: function(){
			var highlights = [];
			$('['+r.Highlights.ATTRIBUTE+']', r.$iframe.contents()).each(function(index, el){
				if(r.returnPageElement(el) === r.Navigation.getPage()){
					highlights.push($(el).attr('data-cfi'));
				}
			});
			// the array must be unique
			return highlights.filter(function(el, index){
				return highlights.indexOf(el) === index;
			});
		},
		reset: function(){
			_highlights = [];
		}
	};

	// Debug flag, used to log various events for debugging purposes
	var _debug = false;
	r.Debug = {
		enable: function enableDebug(){
			_debug = true;
		},
		disable: function disableDebug(){
			_debug = false;
		},
		log: function logDebug(s){
			if(_debug){
				console.warn(s);
			}
		},
		error: function logDebug(s){
			if(_debug){
				console.error(s);
			}
		}
	};

	return r;
}(Reader || {}));

'use strict';

var Reader = (function (r) {
	// The **CFI** object exposes methods to handle CFIs. it is **not** intended to be exposed to the client directly.
	//
	// * [`setUp`](#setUp)
	// * [`getCFIObject`](#getCFIObject)
	// * [`setCFI`](#setCFI)
	// * [`addOneNodeToCFI`](#addOneNodeToCFI)
	// * [`addOneWordToCFI`](#addOneWordToCFI)
	// * [`goToCFI`](#goToCFI)
	// * reset

	// Helper methods:
	//
	// * [`getChapterFromCFI`](#getChapterFromCFI)
	//
	// Other private methods
	//
	// * [`getFirstNode`](#getFirstNode)
	r.CFI = {
		// <a name="getCFIObject"></a> Return the current position's CFI and a preview of the current text.
		getCFIObject: function() {
			try {
				var startTextNode = getFirstNode(),
					cfi = r.Epub.generateCFI(startTextNode.textNode, startTextNode.offset),
					result = {
						CFI: cfi,
						preview: startTextNode.preview
					},
					chapter = r.CFI.getChapterFromCFI(result.CFI),
					item = chapter !== -1 ? r.Book.getTOCItem(r.Book.spine[chapter].href, r.Navigation.getPage()) : null;

				if (item) {
					result.chapter = item.label;
					result.href = item.href;
				}

				return result;
			}
			catch (err) {
				// cannot generate CFI
				r.Notify.error($.extend({}, r.Event.ERR_CFI_GENERATION, {details: {message: String(err), stack: err.stack}, call: 'getCFIObject'}));
			}
		},
		getCFI: function() {
			return encodeURIComponent(JSON.stringify(r.CFI.getCFIObject()));
		},
		setBookmarkCFI: function(cfi){
			return r.CFI.setCFI(cfi, r.Bookmarks.ATTRIBUTE);
		},
		setHighlightCFI: function(cfi){
			try {
				var data = r.CFI.parseCFI(cfi);

				// we might have markers injected, we need to handle this
				if(data.startOffset > 0 && data.startElement.nodeType === Node.TEXT_NODE && data.startElement.nodeValue.length < data.startOffset){
					data.startOffset -= data.startElement.nodeValue.length;
					data.startElement = data.startElement.nextSibling.nextSibling;
				}
				if(data.endOffset > 0 && data.endElement.nodeType === Node.TEXT_NODE && data.endElement.nodeValue.length < data.endOffset){
					data.endOffset -= data.endElement.nodeValue.length;
					data.endElement = data.endElement.nextSibling.nextSibling;
				}

				var range = r.$iframe.contents()[0].createRange();
				range.setStart(data.startElement, data.startOffset);
				range.setEnd(data.endElement, data.endOffset);

				var rects = _getClientRects(range), reader = {
					top: r.$reader.offset().top,
					left: r.$reader.offset().left
				};
				for(var i = 0; i < rects.length; i++){
					var rect = rects[i];
					$('<div data-cfi="'+cfi+'" data-highlight></div>')
						.css({
							width: rect.width + 'px',
							height: rect.height + 'px',
							top: rect.top - reader.top + 'px',
							left: rect.left - reader.left + 'px'
						})
						.appendTo(r.$overlay);
				}
			} catch(err){
				// cannot insert CFI
				r.Notify.error($.extend({}, r.Event.ERR_CFI_INSERTION, {details: err, call: 'setHighlightCFI'}));
			}
			return false;
		},
		// <a name="setCFI"></a> This function will inject a blacklisted market into the DOM to allow the user to identify where a CFI points to.
		setCFI: function (cfi, attr) { // Add an element to a CFI point
			var $marker = $('[data-cfi="' + cfi + '"]', r.$iframe.contents()), attrs = attr ? attr.split('=') : '';
			if($marker.length){
				if(attr && !$marker.is('['+attr+']')){
					$marker.attr(attrs[0], attrs.length > 1 ? attrs[1] : '');
				}
			} else {
				try {
					var marker = '<span class="cpr-marker" '+ attr +' data-cfi="' + cfi + '"></span>';
					var $node = r.Epub.getElementAt(cfi);

					// in case the cfi targets an svg child, target the svg element itself
					if($node.parents('svg').length){
						$node = $node.parents('svg');
					}
					if ($node.length) {
						if ($node[0].nodeType === 1) { // append to element
							$node.attr('data-cfi', cfi);
							if(attr){
								$node.attr(attrs[0], attrs.length > 1 ? name[1] : '');
							}
						}
						if ($node[0].nodeType === 3) { // inject into the text node
							r.CFI.addOneWordToCFI(cfi, $node, marker, attr);
						}
					}
					return $node;
				}
				catch (err) {
					// cannot insert CFI
					r.Notify.error($.extend({}, r.Event.ERR_CFI_INSERTION, {details: err, call: 'setCFI'}));
				}
			}
		},
		// <a name="addOneNodeToCFI"></a> Helper function that moves the CFI to the next node. This is required to avoid a bug in some browsers that displays the current CFI on the previous page.
		addOneNodeToCFI : function (cfi, el, marker, attr) {
			var $nextNode = getNextNode(el);

			// get the leaf of next node to inject in the appropriate location
			while ($nextNode && !$nextNode.is('svg') && $nextNode.contents().length){
				$nextNode = $nextNode.contents().first();
			}

			if ($nextNode) {
				if ($nextNode[0].nodeType === 3) {
					if($nextNode[0].length > 1){
						cfi = r.Epub.generateCFI($nextNode[0], 0);
						r.CFI.addOneWordToCFI(cfi, $nextNode, marker, attr, true);
					} else {
						// the text node is not large enought to have a marker injected, need to prepend it
						$nextNode.before(marker);
					}
				} else {
					$nextNode.attr('data-cfi', cfi);
					if(attr){
						var name = attr.split('=');
						$nextNode.attr(name[0], name.length > 1 ? name[1] : '');
					}
				}
				return true;
			}
			return false;
		},
		// <a name="addOneWordToCFI"></a> Add one position to the cfi if we are in a text node to avoid the CFI to be set in the previous page.
		addOneWordToCFI : function (cfi, el, marker, attr, force) {
			var pos = parseInt(cfi.split(':')[1].split(')')[0], 10);
			var words = el.text().substring(pos).split(/\s+/).filter(function(word){
				return word.length;
			});
			// find next word position
			if (el.text().length > 1 && words.length && pos + words[0].length < el.text().length) {
				pos = pos + words[0].length;
				cfi = cfi.split(':')[0] + ':' + pos + ')';
				r.Epub.injectMarker(cfi, marker);
			} else {
				// We must check if there are more nodes in the chapter.
				// If not, we add the marker one character after the cfi position, if possible.
				if(force || !r.CFI.addOneNodeToCFI(cfi, el, marker, attr)){
					pos = pos + 1 < el.text().length ? pos + 1 : pos;
					cfi = cfi.split(':')[0] + ':' + pos + ')';
					r.Epub.injectMarker(cfi, marker);
				}
			}
		},
		isValidCFI: function (cfi) {
			return /^epubcfi\(.+\)$/.test(cfi);
		},
		isRangeCFI: function(cfi){
			return /^epubcfi\(.+,.+,.+\)$/.test(cfi);
		},
		parseCFI: function(cfi){
			if(!r.CFI.isValidCFI(cfi)){
				return false;
			}

			var data = {
				isRange: false
			}, offsetRegex = /(?::)(\d+)(?:\))/;

			if(r.CFI.isRangeCFI(cfi)){
				data.isRange= true;

				var CFIs = cfi.split(',');

				var $nodes = r.Epub.getRangeTargetElements(cfi);
				data.startElement = $nodes[0];
				data.endElement = $nodes[1];
				data.startCFI =  CFIs[0] + CFIs[1] + ')';
				data.endCFI = CFIs[0] + CFIs[2];

				var startOffset = data.startCFI.match(offsetRegex),
					endOffset = data.endCFI.match(offsetRegex);

				data.startOffset = (startOffset && startOffset.length) ? parseInt(startOffset[1], 10) : null;
				data.endOffset = (endOffset && endOffset.length) ? parseInt(endOffset[1], 10) : null;
			} else {
				var offset = cfi.match(offsetRegex);
				
				data.element = r.Epub.getElementAt(cfi);
				data.offset = (offset && offset.length) ? parseInt(offset[1], 10) : null;
			}

			return data;
		},
		getCFISelector: function (cfi) {
			return '*[data-cfi="' + cfi + '"]';
		},
		findCFIElement : function (value) {
			var $elem = $(r.CFI.getCFISelector(value), r.$iframe.contents());
			return $elem.length ? r.returnPageElement($elem) : -1;
		},
		// <a name="goToCFI"></a>Find and load the page that contains the CFI's marker. If the marker does not exist, it will be injected in the chapter. If the CFI points to another chapter it will load that chapter first.
		goToCFI : function (cfi, fixed) {
			var chapter = r.CFI.getChapterFromCFI(cfi);
			if(chapter !== -1){
				if (r.Navigation.getChapter() === chapter && r.Navigation.isCFIInCurrentChapterPart(cfi)) {
					if (r.CFI.findCFIElement(cfi) === -1) {
						// handle range CFIs by assuming the start of the range as the position we want to go to
						var data = r.CFI.parseCFI(cfi);
						if(data && data.isRange){
							cfi = data.startCFI;
						}
						r.CFI.setCFI(cfi);
					}
					return r.Navigation.loadPage(cfi, fixed);
				} else {
					return r.loadChapter(chapter, cfi);
				}
			}
			r.Notify.error($.extend({}, r.Event.ERR_INVALID_ARGUMENT, {details: 'Invalid CFI', value: cfi, call: 'goToCFI'}));
			return $.Deferred().reject().promise();
		},
		// <a name="getChapterFromCFI"></a> This function will calculate what chapter the CFI is pointing at and return the its index (or -1 on failure).
		getChapterFromCFI: function(cfi){
			if($.type(cfi) === 'string'){
				var chapter = cfi.split('/');
				if(chapter.length >= 3 && $.isNumeric(chapter[2].slice(0, -1))){
					return parseInt(parseInt(chapter[2].slice(0, -1), 10) / 2 - 1, 10);
				}
			}
			return -1;
		}
	};

	var _nodeInViewport = function(el, offset){
		// this test is only for text nodes, relates to CR-300
		// caretRangeFromPoint does not always return the correct node for some Android devices (even Kit-Kat)
		// we need to perform a check for all text nodes to ensure that they really appear in the viewport befpre continuing
		if(el.nodeType === 3){
			var range = r.$iframe.contents()[0].createRange();
			range.setStart(el, offset || 0);
			var rects = range.getClientRects();
			if(rects && rects.length){
				var rect = rects[0];
				return rect.left >= 0;
			}
		} else if(el.nodeType === 1){
			// This check is only necessary for iOS webview bug, where caretRangeFromPoint returns the wrong element
			// http://jira.blinkbox.local/jira/browse/CR-320
			return r.returnPageElement(el) === r.Navigation.getPage();
		}
		return true;
	};

	var _getElementAt = function(x, y){
		var range, textNode, offset, doc = r.$iframe.contents()[0];
		/* standard */
		if (doc.caretPositionFromPoint) {
			range = doc.caretPositionFromPoint(x, y);
			textNode = range.offsetNode;
			offset = range.offset;
			/* WebKit */
		} else if (doc.caretRangeFromPoint) {
			range = doc.caretRangeFromPoint(x, y);
			textNode = range.startContainer;
			offset = range.startOffset;
		}

		// We need to ensure the element is within the reader content, visible on the current page and it is not part of a highlight (that appear above the text)
		if(!r.$reader.has(textNode).length || !_nodeInViewport(textNode, offset) || textNode.parentNode.id === 'cpr-overlay'){
			var columnWidth = Math.floor(r.Layout.Reader.width / r.Layout.Reader.columns - r.Layout.Reader.padding / 2),
				columnHeight = r.Layout.Reader.height;
			
			if(x <= 3/4 * columnWidth){
				x += columnWidth / 4;
				return _getElementAt(x, y);
			} else if(y <= 3/4 * columnHeight){
				y += columnHeight / 4;
				return _getElementAt(x, y);
			}
			return null;
		}
		return {
			textNode: textNode,
			offset: offset
		};
	};

	// <a name="getFirstNode"></a> Helper function that returns the first node in the current page displayed by the reader.
	var getFirstNode = function () {

		var rect = r.$reader[0].getBoundingClientRect();
		var left = r.getReaderLeftPosition();
		var result = _getElementAt(rect.left - left, rect.top);
		var textNode;
		var offset;

		/* Make sure textNode is part of the reader... */
		if (!result) {
			/* Reset offset since textNode changed. */
			offset = 0;
			var $firstElementInViewport = r.$reader.find(':visible:not(.'+ r.Epub.BLACKLIST.join(',.')+')').filter(function(){
				var offset =  $(this).offset();
					// some paragraphs client rect appear above the reader, even though the text itself wraps on the previous page as well
				return offset.left >= 0 && offset.top >= rect.top;
			}).first();

			if($firstElementInViewport.length){
				textNode = $firstElementInViewport[0];
			} else {
				textNode = r.$reader.children().filter(function(){
					return $(this).text().trim().length;
				}).first()[0];
			}
		} else {
			textNode = result.textNode;
			offset = result.offset;
		}

		// The target node cannot be a child of svg, any marker generated will be invisible, will return the svg itself
		if($(textNode).parents('svg').length){
			textNode = $(textNode).parents('svg')[0];
			offset = 0;
		}

		var findLeafNode = function (el) {
			var $el = $(el);
			/* Return a non-empty textNode or null */
			if (el === null || el.nodeName === 'svg' || !el.childNodes || el.childNodes.length === 0) {
				return el;
			}
			/* Return the element if it only has one child and it is in the blacklist */
			if (el.childNodes.length === 1 && _hasClass($el.contents(), r.Epub.BLACKLIST)) { // TODO: Explore more options
				return el;
			}
			// only take into consideration DOM nodes and text nodes, ignore anything else (including comments)
			var contents = $el.contents();
			for(var i = 0, l = contents.length; i < l; i++){
				var child = contents[i];
				if((child.nodeType === 1 && !_hasClass($(child), r.Epub.BLACKLIST)) || child.nodeType === 3){
					/* reset offset since textNode changed */
					offset = 0;
					return findLeafNode(child);
				}
			}
			return el;
		};

		/* generate a preview from the current position */
		var preview = '';

		// Calculates the length of a string and returns true if the length has the minimum number of words.
		// Returns true if text is a string and its length is > than the desired number of words, false otherwise.
		var hasDesiredLength = function (text) {
			// Check number of words so far.
			var words = text.match(/\S+/g);
			return words && words.length > 100;
		};

		var _hasClass = function (el, classNames) {
			var classes = '.' + classNames.join(', .');
			return el.filter(classes).length > 0;
		};

		// Loops through all adjacent nodes to generate the preview, starting with the first text node.
		var generatePreview = function () {
			var ellipsis = '…';
			var $currentNode = $(textNode);
			var text = offset ? ellipsis + $currentNode.text().substr(offset) : $currentNode.text(); // prepend ellipses to previews which don't begin at the start of a sentence
			while (!hasDesiredLength(text)) {
				var $next = getNextNode($currentNode);

				if ($next && $next.length) {
					$currentNode = $next;
					text += $currentNode.text().length && $currentNode[0].tagName !== 'SCRIPT' ? $currentNode.text() : '';
				} else {
					// No more content go get text from, break operation.
					break;
				}
			}

			// Trim preview to 100 words.
			var trimmed = text.replace(/\s+/g, ' ').trim().match(/((\S+\s+){100})/);
			return trimmed && trimmed.length ? trimmed[0].replace(/\s+$/, ellipsis) : text;
		};

		// Get the top element that is the child of the reader container.
		var $currentNode = $(textNode);
		while ($currentNode.parent().length && !$currentNode.parent().is(r.$reader)) {
			$currentNode = $currentNode.parent();
		}

		// Check that the first tag has text, if not, add any image/table we can find.
		if (!$currentNode.text().trim().length) {
			var $img = $currentNode.find('img');
			var $table = $currentNode.find('table');
			var $svg = $currentNode.find('svg');

			if ($img.length) {
				preview = 'Image: ' + ($img.attr('alt') ? $img.attr('alt') : 'No description');
			} else if ($table.length) {
				preview = 'Table';
			} else if ($svg.length) {
				preview = 'Image: No description';
			}
		} else {
			preview = generatePreview();
		}

		return {
			textNode: findLeafNode(textNode),
			offset: offset,
			preview: preview
		};
	};

	var _rangeIntersectsNode = function(range, node) {
		var nodeRange = node.ownerDocument.createRange();
		try {
			nodeRange.selectNode(node);
		} catch (e) {
			nodeRange.selectNodeContents(node);
		}

		var rangeStartRange = range.cloneRange();
		rangeStartRange.collapse(true);

		var rangeEndRange = range.cloneRange();
		rangeEndRange.collapse(false);

		var nodeStartRange = nodeRange.cloneRange();
		nodeStartRange.collapse(true);

		var nodeEndRange = nodeRange.cloneRange();
		nodeEndRange.collapse(false);

		return rangeStartRange.compareBoundaryPoints(
			Range.START_TO_START, nodeEndRange) === -1 &&
			rangeEndRange.compareBoundaryPoints(
				Range.START_TO_START, nodeStartRange) === 1;
	};

	var _getClientRects = function(range){
		var containerElement = range.commonAncestorContainer,
			treeWalker = document.createTreeWalker(
			containerElement,
			NodeFilter.SHOW_TEXT,
			{
				acceptNode: function(node) {
					return (
						!node.isEqualNode(range.startContainer) &&
						!node.isEqualNode(range.endContainer) &&
						node.nodeValue.trim().length &&
						_rangeIntersectsNode(range, node)
					) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
				}
			},
			false
			),
			rects = [],
			rect,
			i,
			l,
			r = document.createRange();

		if(range.startContainer.isEqualNode(range.endContainer)){
			r.setStart(range.startContainer, range.startOffset);
			r.setEnd(range.endContainer, range.endOffset);
			rect = r.getClientRects();
			for(i = 0, l = rect.length; i < l; i++){
				rects.push(rect[i]);
			}
		} else {
			r.setStart(range.startContainer, range.startOffset);
			r.setEnd(range.startContainer, range.startContainer.nodeValue.length);
			rect = r.getClientRects();
			for(i = 0, l = rect.length; i < l; i++){
				rects.push(rect[i]);
			}

			r.setStart(range.endContainer, 0);
			r.setEnd(range.endContainer, range.endOffset);
			rect = r.getClientRects();
			for(i = 0, l = rect.length; i < l; i++){
				rects.push(rect[i]);
			}
		}


		while (treeWalker.nextNode()) {
			r.selectNode(treeWalker.currentNode);
			rect = r.getClientRects();
			for(i = 0, l = rect.length; i < l; i++){
				rects.push(rect[i]);
			}
		}

		return rects;
	};

	var getNextNode = function ($el) {
		$el = $el.last();
		var nodes = $el.parent().contents(),
				blacklisted = r.Epub.BLACKLIST.join(',.'),
				i,
				next,
				$next;
		for (i = nodes.index($el) + 1; i < nodes.length; i++) {
			next = nodes[i];
			$next = $(next);
			if (next.nodeType === 3 && $next.text().trim().length ||                          // Return either a non-empty text node or
				next.nodeType === 1 && !$next.hasClass(blacklisted) && $next.is(':visible')) {  // a visible, non-blacklisted element node
				return $next;
			}
		}
		if (!$el.parent().is(r.$reader)) {
			return getNextNode($el.parent());
		}
	};

	return r;
}(Reader || {}));
/**
 * ReaderJS v1.0.0
 * (c) 2013 BlinkboxBooks
 * config.js: contains global variables
 */

/* jshint unused: true */
/* exported Reader */
/* globals $ */

var Reader = (function (r) {
	'use strict';

	// Constants
	r.DOCROOT = '';
	r.BOOK_INFO_PATH = 'META-INF/book-info.json';
	r.ROOTFILE_INFO_PATH = 'META-INF/container.xml';

	// Initial settings.
	r.$iframe = null;
	r.$wrap = null;
	r.$head = null;
	r.$container = null;
	r.$reader = null;
	r.$header = null;
	r.$footer = null;
	r.$stylesheet = null;
	r.$overlay = null;

	// Indicates if the Reader has been called from a mobile app.
	r.mobile = false;
	// DOM object
	r.listener = null;
	// User-set preferences that are related to the display options.
	var i, rule;

	// Helper function to restrict the bounds of the given preference:
	function restrictBounds(value) {
		/*jshint validthis:true */
		value = Number(value) || 0;
		if (value > this.max) {
			return this.max;
		}
		if (value < this.min) {
			return this.min;
		}
		return value;
	}

	r.preferences = {
		publisherStyles: {
			value: true
		},
		doubleTapDelay: {
			min: 100,
			max: 1000,
			value: 350,
			clear: restrictBounds
		},
		loadProgressData: {
			min: 0,
			max: 2,
			value: 2, // 0 -> disabled, 1 -> load progress on book load, 2 -> load progress after initial chapter load
			clear: restrictBounds
		},
		imageWordCount: {
			min: 1,
			max: 1000,
			value: 100,
			clear: restrictBounds
		},
		maxParallelRequests: {
			min: 1,
			max: 10,
			value: 5,
			clear: restrictBounds
		},
		maxChapterElements: {
			min: 100,
			max: 10000,
			value: 200,
			clear: restrictBounds
		},
		// Preload range for lazy image loading (indicates the number of pages around the current page on which images are preloaded):
		preloadRange: {
			min: 1,
			max: 10,
			value: 2,
			clear: restrictBounds
		},
		transitionDuration: {
			min: 0,
			max: 1,
			value: 0.3,
			clear: restrictBounds
		},
		transitionTimingFunction: {
			value: 'ease-in-out'
		},
		lineHeight : {
			rules: [],
			min: 1.1,
			max: 20,
			unit: 0.1,
			value: 1.6,
			clear: restrictBounds,
			applyRules: function(){
				for(i = 0; i< r.preferences.lineHeight.rules.length; i++){
					rule = r.preferences.lineHeight.rules[i];
					rule.rule[rule.property] = r.preferences.lineHeight.value;
				}
			}
		},
		fontSize : {
			rules: [],
			min: 0.5,
			max: 15,
			unit: 0.1,
			value: 1,
			clear: restrictBounds,
			applyRules: function(){
				for(i = 0; i< r.preferences.fontSize.rules.length; i++){
					rule = r.preferences.fontSize.rules[i];
					rule.rule[rule.property] = r.preferences.fontSize.value * 18 + 'px';
				}
			}
		},
		fontFamily : {
			rules: [],
			value: '',
			clear: function (value) {
				return typeof(value) === 'string' ? value : this.value;
			},
			applyRules: function(){
				for(i = 0; i< r.preferences.fontFamily.rules.length; i++){
					rule = r.preferences.fontFamily.rules[i];
					rule.rule[rule.property] = r.preferences.fontFamily.value;
				}
			}
		},
		margin : { // top, right, bottom, left
			min : [9.8, 4, 6.5, 4],
			max: [9.8, 17.75, 6.5, 17.75],
			medium: [9.8, 11, 6.5, 11],
			value: [9.8, 11, 6.5, 11],
			// Helper function that sets a valid margin from an argument.
			clear: function(args){
				// Replace keywords with their respective values...
				if(args === 'min'){
					args = r.preferences.margin.min;
					return args;
				}
				else if(args === 'max'){
					args = r.preferences.margin.max;
					return args;
				}
				if(args === 'medium'){
					args = r.preferences.margin.medium;
					return args;
				}
				// Make sure the args are an array of length 4...
				if(!Array.isArray(args) || args.length !== 4){
					// Only send error notification if the client actually attemted to set the value
					if(args){
						r.Notify.error($.extend({}, r.Event.ERR_INVALID_ARGUMENT, {value: args, details: 'The reader margin has to be defined as either min, max or medium. Alternatively, you can define your own values by sending an array in the following format [top, right, bottom, left].', call: 'margin'}));
					}
					args = r.preferences.margin.value;
				}

				// Make sure bounds are respected...
				for(var i = 0; i < args.length; i++){
					args[i] = args[i] < r.preferences.margin.min[i] ? r.preferences.margin.min[i] : args[i];
					args[i] = args[i] > r.preferences.margin.max[i] ? r.preferences.margin.max[i] : args[i];
				}
				return args;
			}
		},
		theme : {
			rules: {
				background: [],
				title: [],
				color: []
			},
			transparent : {
				background : 'transparent',
				title : '#666',
				color : '#000'
			},
			light : {
				background : '#f4f4f4',
				title : '#666',
				color : '#000'
			},
			dark : {
				background : '#000000',
				title : '#666',
				color : '#dddddd'
			},
			sepia : {
				background : '#ede7d5',
				title : '#666',
				color : '#181818'
			},
			value : {
				background : '#f4f4f4',
				title : '#666',
				color : '#000'
			},
			clear : function(args){
				if(args === 'light' || args === 'dark' || args === 'sepia' || args === 'transparent'){
					return r.preferences.theme[args];
				}
				if(typeof(args) === 'object' && args.hasOwnProperty('color') && args.hasOwnProperty('background') && args.hasOwnProperty('title')){
					return args;
				}
				if(args){
					r.Notify.error($.extend({}, r.Event.ERR_INVALID_ARGUMENT, {value: args, details: 'The reader theme has to be either transparent, light, dark or sepia. Alternatively you can set your own custom theme by sending an object with background and color properties defined.', call: 'theme'}));
				}
				return r.preferences.theme.value;
			},
			applyRules: function(){
				for(i = 0; i< r.preferences.theme.rules.background.length; i++){
					rule = r.preferences.theme.rules.background[i];
					rule.rule[rule.property] = r.preferences.theme.value.background;
				}
				for(i = 0; i< r.preferences.theme.rules.title.length; i++){
					rule = r.preferences.theme.rules.title[i];
					rule.rule[rule.property] = r.preferences.theme.value.title;
				}
				for(i = 0; i< r.preferences.theme.rules.color.length; i++){
					rule = r.preferences.theme.rules.color[i];
					rule.rule[rule.property] = r.preferences.theme.value.color;
				}
			}
		},
		textAlign:{
			rules: [],
			values: ['left', 'justify'],
			value: 'left',
			clear: function(args){
				if(args && (typeof(args) !== 'string' || $.inArray(args, r.preferences.textAlign.values) === -1)){
					r.Notify.error($.extend({}, r.Event.ERR_INVALID_ARGUMENT, {value: args, details: 'The text align has to be either left or justify.', call: 'textAlign'}));
					return r.preferences.textAlign.value;
				}
				return args;
			},
			applyRules: function(){
				for(i = 0; i< r.preferences.textAlign.rules.length; i++){
					rule = r.preferences.textAlign.rules[i];
					rule.rule[rule.property] = r.preferences.textAlign.value;
				}
			}
		},
		applyAll: function(){
			r.preferences.lineHeight.applyRules();
			r.preferences.fontSize.applyRules();
			r.preferences.fontFamily.applyRules();
			r.preferences.theme.applyRules();
			r.preferences.lineHeight.applyRules();
			r.preferences.textAlign.applyRules();
		}
	};
	return r;

}(Reader || {}));
/**
 * ReaderJS v1.0.0
 * (c) 2013 BlinkboxBooks
 * display.js: methods for create the container and display the content
 */

/* jshint unused: true */
/* exported Reader */
/* globals $, Bugsense */

var Reader = (function (r) {
	'use strict';

	// **Init function**
	//
	// Assign parameters to the global variables.
	//
	// * `param` Contains the parameters: container (id), chapters, padding, url, mobile, dimensions (width and height) etc.
	r.init = function(param) {
		r.reset();

		if (!param) {
			param = {};
		}

		// Take the params {container, chapters, width, height, padding, _mobile} or create them.
		// todo validate container
		r.$parent = $(param.container).empty();
		r.$iframe = $('<iframe id="cpr-iframe" name="reader" scrolling="no" seamless="seamless" src="javascript:undefined;"></iframe>').appendTo(r.$parent);
		r.$head = r.$iframe.contents().find('head');
		r.$wrap = r.$iframe.contents().find('body');
		r.$container = $('<div></div>').appendTo(r.$wrap);
		r.$reader = $('<div id="cpr-reader"></div>').appendTo(r.$container);
		r.$header = $('<div id="cpr-header"></div>').insertBefore(r.$container);
		r.$footer = $('<div id="cpr-footer"></div>').insertAfter(r.$container);

		// Add bookmark mark
		$('<span id="cpr-bookmark-ui"></span>').insertAfter(r.$container);

		// add styles and fonts
		_addStyles();

		r.listener = (param.hasOwnProperty('listener')) ? param.listener : null;

		r.DOCROOT = (param.hasOwnProperty('url')) ? param.url : '';
		r.ISBN = (param.hasOwnProperty('isbn')) ? param.isbn : '';

		// Set the mobile flag.
		r.mobile = !!((param.hasOwnProperty('mobile')));

		// Initialise the epub module
		r.Epub.init(r.$reader[0]);

		// Initialize the touch module:
		r.Touch.init(r.$iframe.contents());

		// Resize the container with the width and height (if they exist).
		_createContainer(param.width, param.height, param.columns, param.padding);

		// Apply all user preferences
		r.setPreferences(param.preferences);

		// Set initial transition timing function:
		r.$reader.css('transition-timing-function', r.preferences.transitionTimingFunction.value);

		r.support = {
			transitionend: _getTransitionEndProperty()
		};

		r.Layout.resizeContainer(param);

		// Enable bugsense reporting
		_setBugsense();

		// Start the party:
		return r.Book.load(param.book).then(function (book) {
			// Save the initial bookmarks and highlights.
			r.Bookmarks.setBookmarks((param.hasOwnProperty('bookmarks')) ? param.bookmarks : [], true);
			r.Highlights.setHighlights((param.hasOwnProperty('highlights')) ? param.highlights : [], true);

			return initializeBook(book, param);
		});
	};

	function _getTransitionEndProperty() {
		var element= document.createElement('div');
		if (element.style.webkitTransition !== undefined) {
			return 'webkitTransitionEnd';
		}
		if (element.style.MozTransition !== undefined) {
			return 'transitionend';
		}
		if (element.style.OTransition !== undefined) {
			return 'otransitionend';
		}
		if (element.style.transition !== undefined) {
			return 'transitionend';
		}
	}

	function _addStyles() {
		var styles = 'html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background:0 0}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}#cpr-bookmark-ui{display:none;position:absolute;right:0;top:0;background:#111;width:30px;height:30px;box-shadow:0 0 3px #666}#cpr-bookmark-ui::before{position:absolute;content:"";right:0;top:0;width:0;height:0;border:15px solid #000;border-right-color:transparent;border-top-color:transparent}#cpr-footer{color:#000;line-height:30px;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:18px;font-family:sans-serif}#cpr-header{color:#000;line-height:30px;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;width:100%;font-size:18px;font-family:sans-serif}.cpr-placeholder{visibility:hidden;width:auto;height:100%}*{box-sizing:border-box}html{font-size:18px}body{background:#fff;color:#000;position:relative;overflow:hidden;word-wrap:break-word;font-family:sans-serif;font-weight:400;font-style:normal;text-decoration:none;text-align:left;line-height:1.2;padding:0;margin:0;font-size:1rem}body #cpr-reader{-webkit-backface-visibility:hidden;-webkit-perspective:1000;backface-visibility:hidden;perspective:1000;will-change:transform,opacity}h1,h2,h3,h4,h5,h6{font-weight:700;line-height:1.2;margin:0 0 .67em;clear:both}h1{font-size:1.5rem}h2{font-size:1.4rem}h3{font-size:1.3rem}h4{font-size:1.2rem}h5{font-size:1.1rem}h6{font-size:1rem}p{margin:0 0 1rem}div:last-child,p:last-child{margin-bottom:0}blockquote{border-left:4px solid #e1e1e1;padding:0 1rem 0 1.4rem}:link{color:#09f;text-decoration:underline}:link[data-link-type=external]:after{content:"";background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAKRGlDQ1BJQ0MgUHJvZmlsZQAASA2dlndUFNcXx9/MbC+0XZYiZem9twWkLr1IlSYKy+4CS1nWZRewN0QFIoqICFYkKGLAaCgSK6JYCAgW7AEJIkoMRhEVlczGHPX3Oyf5/U7eH3c+8333nnfn3vvOGQAoASECYQ6sAEC2UCKO9PdmxsUnMPG9AAZEgAM2AHC4uaLQKL9ogK5AXzYzF3WS8V8LAuD1LYBaAK5bBIQzmX/p/+9DkSsSSwCAwtEAOx4/l4tyIcpZ+RKRTJ9EmZ6SKWMYI2MxmiDKqjJO+8Tmf/p8Yk8Z87KFPNRHlrOIl82TcRfKG/OkfJSREJSL8gT8fJRvoKyfJc0WoPwGZXo2n5MLAIYi0yV8bjrK1ihTxNGRbJTnAkCgpH3FKV+xhF+A5gkAO0e0RCxIS5cwjbkmTBtnZxYzgJ+fxZdILMI53EyOmMdk52SLOMIlAHz6ZlkUUJLVlokW2dHG2dHRwtYSLf/n9Y+bn73+GWS9/eTxMuLPnkGMni/al9gvWk4tAKwptDZbvmgpOwFoWw+A6t0vmv4+AOQLAWjt++p7GLJ5SZdIRC5WVvn5+ZYCPtdSVtDP6386fPb8e/jqPEvZeZ9rx/Thp3KkWRKmrKjcnKwcqZiZK+Jw+UyL/x7ifx34VVpf5WEeyU/li/lC9KgYdMoEwjS03UKeQCLIETIFwr/r8L8M+yoHGX6aaxRodR8BPckSKPTRAfJrD8DQyABJ3IPuQJ/7FkKMAbKbF6s99mnuUUb3/7T/YeAy9BXOFaQxZTI7MprJlYrzZIzeCZnBAhKQB3SgBrSAHjAGFsAWOAFX4Al8QRAIA9EgHiwCXJAOsoEY5IPlYA0oAiVgC9gOqsFeUAcaQBM4BtrASXAOXARXwTVwE9wDQ2AUPAOT4DWYgSAID1EhGqQGaUMGkBlkC7Egd8gXCoEioXgoGUqDhJAUWg6tg0qgcqga2g81QN9DJ6Bz0GWoH7oDDUPj0O/QOxiBKTAd1oQNYSuYBXvBwXA0vBBOgxfDS+FCeDNcBdfCR+BW+Bx8Fb4JD8HP4CkEIGSEgeggFggLYSNhSAKSioiRlUgxUonUIk1IB9KNXEeGkAnkLQaHoWGYGAuMKyYAMx/DxSzGrMSUYqoxhzCtmC7MdcwwZhLzEUvFamDNsC7YQGwcNg2bjy3CVmLrsS3YC9ib2FHsaxwOx8AZ4ZxwAbh4XAZuGa4UtxvXjDuL68eN4KbweLwa3gzvhg/Dc/ASfBF+J/4I/gx+AD+Kf0MgE7QJtgQ/QgJBSFhLqCQcJpwmDBDGCDNEBaIB0YUYRuQRlxDLiHXEDmIfcZQ4Q1IkGZHcSNGkDNIaUhWpiXSBdJ/0kkwm65KdyRFkAXk1uYp8lHyJPEx+S1GimFLYlESKlLKZcpBylnKH8pJKpRpSPakJVAl1M7WBep76kPpGjiZnKRcox5NbJVcj1yo3IPdcnihvIO8lv0h+qXyl/HH5PvkJBaKCoQJbgaOwUqFG4YTCoMKUIk3RRjFMMVuxVPGw4mXFJ0p4JUMlXyWeUqHSAaXzSiM0hKZHY9O4tHW0OtoF2igdRzeiB9Iz6CX07+i99EllJWV75RjlAuUa5VPKQwyEYcgIZGQxyhjHGLcY71Q0VbxU+CqbVJpUBlSmVeeoeqryVYtVm1Vvqr5TY6r5qmWqbVVrU3ugjlE3VY9Qz1ffo35BfWIOfY7rHO6c4jnH5tzVgDVMNSI1lmkc0OjRmNLU0vTXFGnu1DyvOaHF0PLUytCq0DqtNa5N03bXFmhXaJ/RfspUZnoxs5hVzC7mpI6GToCOVGe/Tq/OjK6R7nzdtbrNug/0SHosvVS9Cr1OvUl9bf1Q/eX6jfp3DYgGLIN0gx0G3QbThkaGsYYbDNsMnxipGgUaLTVqNLpvTDX2MF5sXGt8wwRnwjLJNNltcs0UNnUwTTetMe0zg80czQRmu836zbHmzuZC81rzQQuKhZdFnkWjxbAlwzLEcq1lm+VzK32rBKutVt1WH60drLOs66zv2SjZBNmstemw+d3W1JZrW2N7w45q52e3yq7d7oW9mT3ffo/9bQeaQ6jDBodOhw+OTo5ixybHcSd9p2SnXU6DLDornFXKuuSMdfZ2XuV80vmti6OLxOWYy2+uFq6Zroddn8w1msufWzd3xE3XjeO2323Ineme7L7PfchDx4PjUevxyFPPk+dZ7znmZeKV4XXE67m3tbfYu8V7mu3CXsE+64P4+PsU+/T6KvnO9632fein65fm1+g36e/gv8z/bAA2IDhga8BgoGYgN7AhcDLIKWhFUFcwJTgquDr4UYhpiDikIxQODQrdFnp/nsE84by2MBAWGLYt7EG4Ufji8B8jcBHhETURjyNtIpdHdkfRopKiDke9jvaOLou+N994vnR+Z4x8TGJMQ8x0rE9seexQnFXcirir8erxgvj2BHxCTEJ9wtQC3wXbF4wmOiQWJd5aaLSwYOHlReqLshadSpJP4iQdT8YmxyYfTn7PCePUcqZSAlN2pUxy2dwd3Gc8T14Fb5zvxi/nj6W6pZanPklzS9uWNp7ukV6ZPiFgC6oFLzICMvZmTGeGZR7MnM2KzWrOJmQnZ58QKgkzhV05WjkFOf0iM1GRaGixy+LtiyfFweL6XCh3YW67hI7+TPVIjaXrpcN57nk1eW/yY/KPFygWCAt6lpgu2bRkbKnf0m+XYZZxl3Uu11m+ZvnwCq8V+1dCK1NWdq7SW1W4anS1/+pDa0hrMtf8tNZ6bfnaV+ti13UUahauLhxZ77++sUiuSFw0uMF1w96NmI2Cjb2b7Dbt3PSxmFd8pcS6pLLkfSm39Mo3Nt9UfTO7OXVzb5lj2Z4tuC3CLbe2emw9VK5YvrR8ZFvottYKZkVxxavtSdsvV9pX7t1B2iHdMVQVUtW+U3/nlp3vq9Orb9Z41zTv0ti1adf0bt7ugT2ee5r2au4t2ftun2Df7f3++1trDWsrD+AO5B14XBdT1/0t69uGevX6kvoPB4UHhw5FHupqcGpoOKxxuKwRbpQ2jh9JPHLtO5/v2pssmvY3M5pLjoKj0qNPv0/+/tax4GOdx1nHm34w+GFXC62luBVqXdI62ZbeNtQe395/IuhEZ4drR8uPlj8ePKlzsuaU8qmy06TThadnzyw9M3VWdHbiXNq5kc6kznvn487f6Iro6r0QfOHSRb+L57u9us9ccrt08rLL5RNXWFfarjpebe1x6Gn5yeGnll7H3tY+p772a87XOvrn9p8e8Bg4d93n+sUbgTeu3px3s//W/Fu3BxMHh27zbj+5k3Xnxd28uzP3Vt/H3i9+oPCg8qHGw9qfTX5uHnIcOjXsM9zzKOrRvRHuyLNfcn95P1r4mPq4ckx7rOGJ7ZOT437j154ueDr6TPRsZqLoV8Vfdz03fv7Db56/9UzGTY6+EL+Y/b30pdrLg6/sX3VOhU89fJ39ema6+I3am0NvWW+738W+G5vJf49/X/XB5EPHx+CP92ezZ2f/AAOY8/wRDtFgAAAACXBIWXMAAAsTAAALEwEAmpwYAAADx2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDx4bXA6TW9kaWZ5RGF0ZT4yMDE0LTA1LTI4VDA5OjU4OjE5PC94bXA6TW9kaWZ5RGF0ZT4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKE1hY2ludG9zaCk8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgICAgPHhtcDpDcmVhdGVEYXRlPjIwMTMtMDgtMDhUMTA6MTI6MzU8L3htcDpDcmVhdGVEYXRlPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj43MjwvdGlmZjpZUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6UmVzb2x1dGlvblVuaXQ+MjwvdGlmZjpSZXNvbHV0aW9uVW5pdD4KICAgICAgICAgPHRpZmY6WFJlc29sdXRpb24+NzI8L3RpZmY6WFJlc29sdXRpb24+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+MTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+NjAwPC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjY0MDc8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4K/AFthgAAAJhJREFUOBHNklEOgCAIhjG7VXWdOlOdx47lLHRuxBgT50O9BPj3AX8CDHoccvyVAiRYGpkhHm7j2ikX2iEoXzkE85kW3055QlqjsT9TojmNPyB6IMVaIxHU41nxiLfv8EycqHK1VVBDPZMnqiTD++cgurNhqywtqzm4rR9yff5rcXfitediLR9mtnqPLJ7JE1k8s2g1b+rZA2oNIaRRHfQPAAAAAElFTkSuQmCC) 0 0 no-repeat;background-size:cover;width:.6rem;height:.6rem;display:inline-block;vertical-align:top;margin:0 0 0 .2rem}:link *{color:#09f}img,svg,svg *{max-width:100%;max-height:100%}img.cpr-img-large,svg .cpr-img-large,svg.cpr-img-large{display:inline-block;margin:0 auto .5rem}img.cpr-img-large:last-child,svg .cpr-img-large:last-child,svg.cpr-img-large:last-child{margin-bottom:0}img.cpr-img-large .cpr-subchapter-link,svg .cpr-img-large .cpr-subchapter-link,svg.cpr-img-large .cpr-subchapter-link{display:none}img.cpr-img-medium,svg .cpr-img-medium,svg.cpr-img-medium{margin:0 .5rem .5rem 0}img.cpr-img-small,svg .cpr-img-small,svg.cpr-img-small{display:inline}.cpr-highlight div{position:absolute;top:0;left:0;display:inline-block;background:#ff0;opacity:.2}';

		var $style = $('<style>' + styles + '</style>').appendTo(r.$head);

		// Save a reference for each style
		var rules = $style[0].sheet.cssRules;
		var i, l= rules.length;
		for(i=0; i< l; i++){
			var rule = rules[i];
			if(rule.selectorText === 'html'){
				r.preferences.fontSize.rules.push({rule: rule.style, property: 'fontSize'});
			} else if(rule.selectorText === 'body'){
				r.preferences.lineHeight.rules.push({rule: rule.style, property: 'lineHeight'});
				r.preferences.fontFamily.rules.push({rule: rule.style, property: 'fontFamily'});
				r.preferences.textAlign.rules.push({rule: rule.style, property: 'textAlign'});
				r.preferences.theme.rules.color.push({rule: rule.style, property: 'color'});
				r.preferences.theme.rules.background.push({rule: rule.style, property: 'background'});
			} else if(rule.selectorText === '#cpr-header' || rule.selectorText === '#cpr-footer'){
				r.preferences.theme.rules.title.push({rule: rule.style, property: 'color'});
			} else if(rule.selectorText === '#cpr-bookmark-ui'){
				r.preferences.theme.rules.background.push({rule: rule.style, property: 'background'});
			}
		}

		// Note, this is injected regardless if it exists or not
		if(!r.mobile){
			r.$head.append('<link href=\'//fonts.googleapis.com/css?family=Droid+Serif:400,700,700italic,400italic\' rel=\'stylesheet\' type=\'text/css\'>');
		}
	}

	function _setBugsense() {
		if (typeof Bugsense === 'function') {
			r.Bugsense = new Bugsense({
				apiKey: 'f38df951',
				appName: 'CPR',
				appversion: '1.0.6-78'
			});
			// Setup error handler
			window.onerror = function (message, url, line) {
				r.Notify.error(message, url, line);
				return false;
			};
		}
	}

	function _highlightHandler(e){
		var x = e.type === 'touchstart' ? e.originalEvent.touches[0].clientX : e.clientX,
			y = e.type === 'touchstart' ? e.originalEvent.touches[0].clientY : e.clientY;

		/*jshint validthis:true */
		r.Notify.event($.extend({}, Reader.Event.HIGHLIGHT_TAPPED, {call: 'userClick', cfi: $(this).attr('data-cfi'), clientX: x, clientY: y}));
		e.preventDefault();
		e.stopPropagation();
	}

	// Capture all the links in the reader
	function _clickHandler(e) {
		/*jshint validthis:true */
		// Retrieve the encoded relative version of the url:
		var url = this.getAttribute('href'),
				type = this.getAttribute('data-link-type');
		e.preventDefault();
		e.stopPropagation();
		if (type === 'external') {
			// External link, notify client about it:
			r.Notify.event($.extend({}, Reader.Event.NOTICE_EXT_LINK, {call: 'userClick', href: url}));
		} else if (type === 'internal') {
			url = this.href.split('/').slice(-url.split('/').length).join('/');
			// Internal link, notify client about it:
			r.Notify.event($.extend({}, Reader.Event.NOTICE_INT_LINK, {call: 'userClick', href: url}));
			// Load the given URL:
			r.Notify.event(r.Event.LOADING_STARTED);
			r.Navigation.loadChapter(url)
				.always(function () {
					r.Notify.event(r.Event.LOADING_COMPLETE);
				})
				.done(function () {
					r.Notify.event($.extend({}, Reader.Event.getStatus(), {call: 'clickLoad', href: url}));
				})
				.fail(function (error) {
					if (error && error.code === r.Event.ERR_INVALID_ARGUMENT.code) {
						r.Notify.event($.extend({}, Reader.Event.CONTENT_NOT_AVAILABLE, {call: 'userClick', href: url}));
					} else {
						r.Notify.error(error);
					}
				});
		}
	}

	// Display HTML content
	//
	// * `param` Contains the parameters: content, page and mimetype
	// * `callback` Function to be called after the function's logic
	function displayContent(param) {
		if (!param) { param = {}; }
		// Take the params values
		var content = (param.hasOwnProperty('content')) ? param.content : '';
		var mimetype = (param.hasOwnProperty('mimetype')) ? param.mimetype : 'application/xhtml+xml';

		r.$header.text(r.Book.title); // TODO Do not polute the reader object.

		// Parse the content according its mime-type and apply all filters attached to display content
		var result = r.parse(content, mimetype, param);
		r.Navigation.setChapterHead(result.$head);
		var promise = r.preferences.publisherStyles.value ? r.addPublisherStyles() : $.Deferred().resolve().promise();

		return promise.then(function(){

			content = r.Filters.applyFilters(r.Filters.HOOKS.BEFORE_CHAPTER_DISPLAY, result.$body);
			r.$reader.html(content);

			r.Filters.applyFilters(r.Filters.HOOKS.AFTER_CHAPTER_DISPLAY);

			// Add all bookmarks for this chapter.
			var bookmarks = r.Bookmarks.getBookmarks()[r.Navigation.getChapter()];
			if(bookmarks){
				$.each(bookmarks, function(index, bookmark){
					// Ignore bookmarks not part of the current chapter part:
					if (bookmark && r.Navigation.isCFIInCurrentChapterPart(bookmark)) {
						r.CFI.setBookmarkCFI(bookmark);
					}
				});
			}

			// Add all highlights for this chapter
			var highlights = r.Highlights.getHighlights()[r.Navigation.getChapter()];
			if(highlights){
				$.each(highlights, function(index, highlight){
					// Ignore bookmarks not part of the current chapter part:
					if (highlight && r.Navigation.isCFIInCurrentChapterPart(highlight)) {
						r.CFI.setHighlightCFI(highlight);
					}
				});
			}
		});
	}

	// Check if the browser supports css-columns.
	function areColumnsSupported() {
		var elemStyle = document.createElement('ch').style,
			domPrefixes = 'Webkit Moz O ms Khtml'.split(' '),
			prop = 'columnCount',
			uc_prop = prop.charAt(0).toUpperCase() + prop.substr(1),
			props   = (prop + ' ' + domPrefixes.join(uc_prop + ' ') + uc_prop).split(' ');

		for ( var i in props ) {
			if ( elemStyle[ props[i] ] !== undefined ) {
				return true;
			}
		}
		return false;
	}

	// Define the container dimensions and create the multi column or adjust the height for the vertical scroll.
	//
	// * `width` In pixels
	// * `height` In pixels
	function _createContainer() {
		r.$iframe.css({
			display: 'inline-block',
			border: 'none'
		});

		r.$reader.addClass(areColumnsSupported() ? 'columns' : 'scroll');

		// Container parent styles.
		r.$container
			.css({
				overflow: 'hidden',
				'-webkit-tap-highlight-color': 'rgba(0,0,0,0)',
				'-webkit-touch-callout': 'none'
			});

		// Capture the anchor links into the content
		r.$container.on('click', 'a', _clickHandler);
		r.$container.on('click touchstart', '.cpr-highlight div', _highlightHandler);
		r.$container.on('touchmove touchend touchcancel', '.cpr-highlight div', function(e){
			// we need to stop all touch events on highlight markers
			e.preventDefault();
			e.stopPropagation();
		});

		// Capture text selection events and notify client of text value.
		var $doc = r.$iframe.contents();
		$doc.bind('selectionchange', function(){
			var selection = $doc[0].getSelection().toString();
			r.Notify.event($.extend({value: selection}, r.Event.TEXT_SELECTION_EVENT));
		});
	}

	function initializeBook(book, param) {
		// Use startCFI if initCFI is not already set:
		var initCFI = param.initCFI || book.startCfi;
		var chapter = r.CFI.getChapterFromCFI(initCFI),
				promise;
		// Validate initCFI (chapter exists):
		if (chapter === -1 || chapter >= book.spine.length) {
			chapter = 0;
			initCFI = null;
		}
		if (initCFI) {
			promise = r.loadChapter(chapter, initCFI);
		} else {
			promise = param.initURL ? r.Navigation.loadChapter(param.initURL) : r.loadChapter(0);
		}
		if (r.preferences.loadProgressData.value === 2) {
			// Load the spine progress data after loading the initial chapter:
			promise.then(function () {
				r.Book.loadProgressData().then(function () {
					r.Navigation.updateProgress();
					r.Notify.event($.extend({}, Reader.Event.getStatus('progressLoad'), {call: 'progressLoad'}));
				});
			});
		}
		return promise;
	}

	// Load a chapter with the index from the spine of this chapter
	r.loadChapter = function(chapterNumber, page) {
		var defer = $.Deferred(),
				chapterUrl = r.Book.spine[chapterNumber].href;

		r.Epub.setUp(chapterNumber, r.Book);
		r.Navigation.setChapter(chapterNumber);
		r.setReaderOpacity(0);

		// success handler for load chapter
		function loadChapterSuccess(data){
			// The url param is required for the chapter divide:
			displayContent({content: data, page: page, url: chapterUrl}).then(function(){

				r.Navigation.setNumberOfPages();

				var cfi = r.CFI.isValidCFI(String(page)) && page;
				if (cfi) {
					r.CFI.goToCFI(cfi).then(defer.resolve);
				} else {
					r.Navigation.loadPage(page).then(defer.resolve);
				}
			}, defer.reject); // Execute the callback inside displayContent when its timer interval finish
		}

		defer.notify({type: 'chapter.loading'});
		r.Book.loadFile(chapterUrl).then(loadChapterSuccess, defer.reject);

		return defer.promise().then(function () {
			// setReaderOpacity returns a promise, but we don't rely on the fade in
			// and the transitionend event does not seem to be fired on the Huddle,
			// so we don't return this promise:
			r.setReaderOpacity(1, r.preferences.transitionDuration.value);
		});
	};

	return r;

}(Reader || {}));

'use strict';

// Helper methods:
//
// * [`updateContext`](#updateContext)
// * [`addContext`](#addContext)
// * [`removeContext`](#removeContext)
// * [`normalizeChapterPartCFI`](#normalizeChapterPartCFI)
// * [`addOneNodeToCFI`](#addOneNodeToCFI)

var Reader = (function (r, Epub) {
	r.Epub = new Epub();
	return r;
}(Reader || {}, (function(r, EPUBcfi){

		var Epub = function(){
			this.context = null;
			this.opfCFI = null;
			this.document = null;
		}, prototype = Epub.prototype;

		// Private array for blacklisted classes. The CFI library will ignore any DOM elements that have these classes.
		// [Read more](https://github.com/readium/EPUBCFI/blob/864527fbb2dd1aaafa034278393d44bba27230df/spec/javascripts/cfi_instruction_spec.js#L137)
		prototype.BLACKLIST = ['cpr-marker', 'cpr-highlight', 'cpr-subchapter-link'];
		prototype.BODY_CFI = '!/4';

		// Initialisation function, called when the reader is initialised.
		prototype.init = function(reader){
			var elCFI = EPUBcfi.generateElementCFIComponent(reader);

			this.document = reader.ownerDocument;
			this.context = elCFI.substring(2); // remove the body cfi step, i.e. /4
		};

		// <a name="setUp"></a> Initialises the CFI variables, should be called whenever we load a new chapter
		// `chapter` the current chapter
		prototype.setUp = function(chapter, book){
			var chapterId = $(book.opfDoc.querySelector('spine')).children()[chapter].getAttribute('idref');

			// EPUBcfi library doesn't handle element namespaces, so we remove them:
			var opf = $(book.opf.replace(/<(\/)?\w+:(\w+)/g, '<$1$2')).filter('package')[0];

			this.opfCFI = EPUBcfi.generatePackageDocumentCFIComponent(chapterId, opf);
		};

		// <a name="addContext"></a> This function will add the context into a CFI to generate a complete and valid CFI to be used with the current chapter.
		prototype.addContext = function(cfi){
			var contextSplit = cfi.split(this.BODY_CFI);
			return contextSplit[0] + this.BODY_CFI + this.context + contextSplit[1];
		};

		// <a name="removeContext"></a> This function will remove the context from a CFI to generate a re-usable, generic, CFI.
		prototype.removeContext = function(cfi){
			return cfi.replace(this.context, '');
		};

		// <a name="normalizeChapterPartCFI"></a> This function normalizes CFI parts to account for chapters which have been split up into multiple parts.
		// todo this method is the only dependency on global Reader object, consider refactoring
		// move getPrevChapterPartMarker and stuff to Epub
		prototype.normalizeChapterPartCFI = function (cfi, remove) {
			// Check if the chapter has been split up into multiple parts:
			var prevChapterPartMarker = r.Navigation.getPrevChapterPartMarker();
			if (prevChapterPartMarker.length) {
				// Get the CFI path for the first non-removed element:
				var chapterMarkerCFI = EPUBcfi.generateElementCFIComponent(prevChapterPartMarker.next()[0], this.BLACKLIST),
					chapterMarkerCompleteCFI = EPUBcfi.generateCompleteCFI(this.opfCFI, chapterMarkerCFI),
					markerCFIParts = chapterMarkerCompleteCFI.split('/'),
					completeCFIParts = cfi.split('/');
				// Check if the elCFI path points to a location inside of the set of reduced chapter part elements:
				if (markerCFIParts.slice(0, -1).join('/') === completeCFIParts.slice(0, markerCFIParts.length - 1).join('/')) {
					var removedElements = r.Navigation.getCurrentChapterPart() * r.preferences.maxChapterElements.value,
					// The incorrect path value, as it doesn't account for the removed elements:
						elPathValue = parseInt(completeCFIParts[markerCFIParts.length - 1], 10),
					// Get the optional path suffix like any ids:
						pathSuffix = completeCFIParts[markerCFIParts.length - 1].slice(String(elPathValue).length);
					// Update the path value with the number of removed elements * 2 (CFI elements always have an even index):
					completeCFIParts[markerCFIParts.length - 1] = (elPathValue + (removedElements * 2 * (remove ? -1 : 1))) + pathSuffix;
					return completeCFIParts.join('/');
				}
			}
			return cfi;
		};

		// Gets the element targetted by a CFI
		prototype.getElementAt = function(cfi){

			cfi = this.addContext(cfi);
			cfi = this.normalizeChapterPartCFI(cfi, true);

			return  $(EPUBcfi.getTargetElement(cfi, this.document, this.BLACKLIST));
		};

		prototype.getRangeTargetElements = function(cfi){
			cfi = this.addContext(cfi);
			cfi = this.normalizeChapterPartCFI(cfi, true);

			var nodes = EPUBcfi.getRangeTargetElements(cfi, this.document, this.BLACKLIST);
			return $([nodes.startElement, nodes.endElement]);
		};

		// Generates the CFI that targets the given element
		prototype.generateCFI = function(el, offset){
			var cfi;

			if (el.nodeType === 3) {
				cfi = EPUBcfi.generateCharacterOffsetCFIComponent(el, offset || 0, this.BLACKLIST);
			} else {
				cfi = EPUBcfi.generateElementCFIComponent(el, this.BLACKLIST);
			}

			cfi = EPUBcfi.generateCompleteCFI(this.opfCFI, cfi);

			cfi = this.normalizeChapterPartCFI(cfi);
			cfi = this.removeContext(cfi);

			return cfi;
		};

		// Generate CFI range for a DOM range element
		prototype.generateRangeCFI = function(range){
			var cfi;

			cfi = EPUBcfi.generateRangeComponent(range.startContainer, range.startOffset, range.endContainer, range.endOffset, this.BLACKLIST);
			cfi = EPUBcfi.generateCompleteCFI(this.opfCFI, cfi);
			cfi = this.normalizeChapterPartCFI(cfi);
			cfi = this.removeContext(cfi);

			return cfi;
		};

		// Injects a marker in the specified position
		prototype.injectMarker = function(cfi, marker){
			cfi = this.addContext(cfi);
			cfi = this.normalizeChapterPartCFI(cfi, true);
			EPUBcfi.injectElement(cfi, r.$iframe.contents()[0], marker, this.BLACKLIST);
		};

		// Injects a marker in the specified range
		prototype.injectRangeMarker = function(cfi, marker){
			cfi = this.addContext(cfi);
			cfi = this.normalizeChapterPartCFI(cfi, true);
			EPUBcfi.injectRangeElements(cfi, r.$iframe.contents()[0], marker, marker, this.BLACKLIST);
		};

		prototype.reset = function(){
			this.opfCFI = null;
			this.context = null;
		};

		return Epub;
	})(Reader || {}, EPUBcfi)));

'use strict';

/* jshint unused: true */
/* exported Reader */
/* globals $ */

var Reader = (function (r) {

	// Register a listener to the reader. Any future events will notify it.
	r.registerListener = function(f){
		if (f && typeof(f) === 'function') {
			r.listener = f;
			return true;
		}
		return false;
	};

	// Check if this is the first or last page of the book, and fire the appropriate event.
	var _check_page_pos = function(status){
		if(status.page === 0 && status.chapter === 0){
			Reader.Notify.event(Reader.Event.FIRST_PAGE);
		}
		if(status.page === (status.pages - 1) && status.chapter === status.chapters - 1){
			Reader.Notify.event(Reader.Event.LAST_PAGE);
		}
		return status;
	};


	// Events supported by the reader.
	//
	// * `LAST_PAGE` - raised when the reader has opened the last page
	// * `LAYOUT_UPDATE` - raised when the number of pages and current page have been updated and possibly changed
	// * `PROGRESS_UPDATED` - event raised when the progress of the book is updated.
	// * `FIRST_PAGE` - event raised when the book displayed the first page of the book.
	// * `END_OF_BOOK`
	r.Event = {
		LAST_PAGE : {
			code: 0,
			message: 'Reader has displayed the last page.'
		},
		END_OF_BOOK : {
			code: 2,
			message: 'The end of the book has been reached.'
		},
		FIRST_PAGE: {
			code: 4,
			message: 'Reader has displayed the first page.'
		},
		LOADING_STARTED: {
			code: 5,
			message: 'Reader is loading.'
		},
		LOADING_COMPLETE: {
			code: 6,
			message: 'Reader has finished loading.'
		},
		STATUS: {
			'code': 7,
			'message': 'Reader has updated its status.',
			'version': '1.0.6-78'
		},
		START_OF_BOOK : {
			code: 8,
			message: 'The start of the book has been reached.'
		},
		ERR_MISSING_FILE:{
			code: 9,
			message: 'A file required by the reader is missing from the ePub.'
		},
		ERR_PARSING_FAILED:{
			code: 10,
			message: 'Parsing of the current chapter failed.'
		},
		ERR_CFI_GENERATION:{
			code: 11,
			message: 'Could not generate a CFI for this location.'
		},
		ERR_CFI_INSERTION:{
			code: 12,
			message: 'Could not insert content at the location specified by the CFI.'

		},
		ERR_INVALID_ARGUMENT:{
			code: 13,
			message: 'An invalid argument was sent to the reader.'
		},
		ERR_BOOKMARK_ADD:{
			code: 14,
			message: 'Could not add the bookmark.'
		},
		ERR_BOOKMARK_EXISTS:{
			code: 15,
			message: 'Could not add the bookmark because one already exists in this location.'
		},
		ERR_BOOKMARK_REMOVE:{
			code: 16,
			message: 'Could not remove bookmark.'
		},
		NOTICE_EXT_LINK:{
			code: 17,
			message: 'External link will navigate away from the reader'
		},
		CONTENT_NOT_AVAILABLE: {
			code: 18,
			message: 'This is a sample, content not available'
		},
		UNHANDLED_TOUCH_EVENT: {
			code: 19,
			message: 'Unhandled touch event at given coordinates.',
      call: 'userClick'
		},
		NOTICE_INT_LINK: {
			code: 20,
			message: 'Internal link was clicked'
		},
		IMAGE_SELECTION_EVENT: {
			code: 21,
			message: 'Double tab event on an image with the given url.',
			call: 'doubleTap'
		},
		TEXT_SELECTION_EVENT: {
			code: 22,
			message: 'Some text has been selected',
			call: 'selection'
		},
		ERR_HIGHLIGHT_ADD:{
			code: 23,
			message: 'Could not add the highlight.'
		},
		ERR_HIGHLIGHT_EXISTS: {
			code: 24,
			message: 'Could not add the highlight because one already exists in this location.'
		},
		ERR_HIGHLIGHT_REMOVE: {
			code: 25,
			message: 'Could not remove highlight.'
		},
		HIGHLIGHT_TAPPED: {
			code: 26,
			message: 'A highlight was clicked.'
		},
		HIGHLIGHT_ADDED: {
			code: 27,
			message: 'A highlight was added.'
		},
		getStatus: function (call) {
			var data = {
				'call': call || '',
				'bookmarksInPage': Reader.Bookmarks.getVisibleBookmarks(), // true if there is a bookmark on the current page
				'bookmarks': Reader.Bookmarks.getBookmarks(), // array of bookmarks from the book
				'highlightsInPage': Reader.Highlights.getVisibleHighlights(), // true if there is a highlight on the current page
				'highlights': Reader.Highlights.getHighlights(), // array of highlights from the book
				'cfi': Reader.Navigation.getCurrentCFI(), // the current CFI
				'progress': Reader.Navigation.getProgress(), // the progress of the book
				'chapter': Reader.Navigation.getChapter(), // the current chapter
				'chapters': Reader.Navigation.getNumberOfChapters(), // total number of chapters
				'page': Reader.Navigation.getPage(), // the current page
				'pages': Reader.Navigation.getNumberOfPages(), // the total number of pages in the current chapter
				'preferences': {
					lineHeight: r.preferences.lineHeight.value,
					fontSize: r.preferences.fontSize.value,
					textAlign: r.preferences.textAlign.value,
					fontFamily: r.preferences.fontFamily.value,
					margin: r.preferences.margin.value,
					theme: r.preferences.theme.value
				},
				'layout': {
					width: r.Layout.Container.width,
					height: r.Layout.Container.height,
					columns: r.Layout.Reader.columns,
					padding: r.Layout.Reader.padding
				}
			};
			if (call === 'init' || call === 'progressLoad') {
				data.book = r.Book.getData();
			}
			return _check_page_pos($.extend({}, r.Event.STATUS, data));
		}
	};

	// Notify clients of reader events
	var _notify = function(data){
		// Notify reader listener, if it exists
		if (r.listener && typeof(r.listener) === 'function') { r.listener(data); }

		// Perform callback to mobile clients
		if(r.mobile){
			$.ajax({
				url: 'BBBCALLBACK',
				type: 'POST',
				data: JSON.stringify(data),
				contentType: 'application/json; charset=utf-8',
				dataType: 'json'
			});
		}
	};

	r.Notify = {
		error: function notifyError(err, url, line){
			r.Debug.error(err);

			_notify(err);
			// only report bugsense for production code
			if(r.Bugsense && r.Event.STATUS.version.indexOf('readerVersion') === -1){
				var error = err;
				if(Object.prototype.toString.call(err) !== '[object Error]'){
					if(err && err.details && Object.prototype.toString.call(err.details) === '[object Error]'){
						error = err.details;
					} else {
						error = new Error(typeof err === 'string' ? err : JSON.stringify(err));
					}
				}
				var status = r.Event.getStatus();
				r.Bugsense.notify(error, url, line, {
					Progress: status.progress + '%',
					Page: (status.page + 1) + '/' + status.pages,
					Chapter: status.chapter + '/' + status.chapters + ' - ' + (status.cfi ? status.cfi.chapter : 'Unknown chapter'),
					Bookmarks: status.bookmarks,
					Book_URL: r.DOCROOT,
					Book_Title: r.Book.title,
					Book_ISBN: r.ISBN,
					CFI: status.cfi ? status.cfi.CFI : 'Unknown CFI',
					Preview: status.cfi ? status.cfi.preview : 'Unknown preview',
					Error: typeof err === 'string' ? err : JSON.stringify(err),
					Preferences: JSON.stringify(status.preferences),
					Layout: JSON.stringify(status.layout)
				});
			}
		},
		event: function notifyEvent(event){
			r.Debug.log(event);

			_notify(event);
		}
	};

	return r;

}(Reader || {}));
'use strict';

var Reader = (function (r) {

	var filters = new FilterJS(), HOOKS = {
		BEFORE_CHAPTER_PARSE: 'beforeChapterParse',
		BEFORE_CHAPTER_DISPLAY: 'beforeChapterDisplay',
		AFTER_CHAPTER_DISPLAY: 'afterChapterDisplay'
	};

	// Build an absolute path from the relative path of a resource
	//
	// * `resourcePath` - relative path to the resource
	//
	// N.B. any relative path of a resource is relative to the containing document's place in the hierachary
	// Notes: relative path permutations (all of which must be handled)
	//
	// 1. Higher up the hierarchy e.g. `../../image.png"`
	// 2. Lower down int the hierarchy e.g. `/images/image.png`
	// 3. In the same hierarchy e.g. `image.png"`
	//
	// contentPathPrefix represents a special case whereby there are path components present in the OPF file path e.g. `/OEPBS/content.opf` which is in turn should be inferred with any resource paths if they don't already exist in the resource path
	var _parseURL = function(resourcePath){
		var absoluteUrl = '',
				docAbsPath = r.DOCROOT,
				href = r.Book.spine[r.Navigation.getChapter()].href,
				pathComponents = href.split('/');

		if (href.indexOf(r.Book.contentPathPrefix) !== 0) {
			// The href didn't start with the content path prefix, so we add it:
			docAbsPath += '/' + r.Book.contentPathPrefix.split('/')[0];
		}
		// Append the document directory path to the absolute path:
		if (pathComponents.length > 1) {
			docAbsPath += '/' + pathComponents.slice(0, -1).join('/');
		}

		if (resourcePath.indexOf('../') === 0) {
			// Case 1 - resource is higher up the hierarchy e.g. `resourcePath = "../../image.png"` - You can find an example in *9780141918921 (Thinking, Fast and Slow)*
			try {
				var docPathComponents = docAbsPath.split('/');
				// Start at the second to the rightmost element document path component (we already know there's at least one '../' present
				var pathComponentIdx = docPathComponents.length-2;
				// Start at the index past the `../`
				var pos = 3;
				do {
					// Search resource path from left to right
					pos = resourcePath.indexOf('../', pos);
					if (pos !== -1) {
						pathComponentIdx--;
						// Skip past the `../`
						pos += 3;
					}
				} while (pos !== -1 );
				// Create the absolute path by using the absDocPath up to the target path component and then appending the resource path
				//
				// Locate the start of the target path component
				var startPos = docAbsPath.indexOf(docPathComponents[pathComponentIdx]);
				var length = docPathComponents[pathComponentIdx].length;
				absoluteUrl += docAbsPath.substring(0, startPos+length);
				// Add the resource path removing any leading `../`
				absoluteUrl += '/'+resourcePath.replace(/\.\.\//g, '');
			}
			catch (e) {
				console.log(e);
			}
		}
		else {
			// Case 2 - resource is lower down int the hierarchy e.g. `resourcePath = images/image.png` - You can find an example in *9781447213291 - The Prince who Walked with Lions*.
			//
			// Case 3 - resource is in the same hierarchy e.g. `resourcePath = "image.png"` - real example: *9781488508493 - Special Greats*.
			//
			// NOTE: docRoot has a trailing slash
			absoluteUrl = docAbsPath.charAt(docAbsPath.length-1) === '/' ? docAbsPath+resourcePath : docAbsPath+'/'+resourcePath;
		}

		// Calculate 95% of the width and height of the column.
		var width = Math.floor(r.Layout.Reader.width / r.Layout.Reader.columns - r.Layout.Reader.padding / 2);
		var height = Math.floor(r.Layout.Reader.height);

		// if url starts with protocol agnostic url, add protocol to avoid Chrome bug
		// if the url is not absolute, add the window location
		if(absoluteUrl.indexOf('//') === 0){
			absoluteUrl = location.protocol + absoluteUrl;
		} else if(absoluteUrl.indexOf('/') === 0){
			absoluteUrl = location.protocol + '//' + location.host + absoluteUrl;
		}
		return absoluteUrl.replace('params;', 'params;img:w='+width+';img:h='+height+';img:m=scale;');
	};

	// add data attributes to anchors
	var _anchorData = function($content){

		$content.find('a[href]').add($content.filter('a[href]')).each(function(i, link){
			var $link = $(link);
			var valid = /^(ftp|http|https):\/\/[^ "]+$/.test($link.attr('href'));
			if (!valid) {
				// ### Internal link.
				$link.attr('data-link-type', 'internal');
				/* elements[idx].attributes[0].nodeValue = 'http://localhost:8888/books/9780718159467/OPS/xhtml/' + elements[idx].attributes[0].nodeValue;*/

				// internal links must be normalized to point to the correct content
				$link.attr('href', _normalizeLink($link.attr('href')));
			} else {
				// ### External link.
				// External links attribute 'target' set to '_blank' for open the new link in another window / tab of the browser.
				$link.attr('data-link-type', 'external').attr('target', '_blank');
			}
		});

		return $content;
	};

	// Rebuild image src
	var _parseImages = function(content){
		// Transform relative image resource paths to absolute
		var images = content.getElementsByTagName('img');
		if (images.length === 0) {
			images = content.getElementsByTagName('IMG');
		}
		// Check if the img tag is a SVG or not as Webkit and IE10 change the tag name.
		for (var i = 0, image = images[i]; image; image = images[++i]) {
			if (image.hasAttribute('src')) {
				var imgSrc = _parseURL(image.getAttribute('src'));
				// Prevent premature loading of img elements:
				image.setAttribute('data-src', imgSrc);
        // Save original URL for the image:
        image.setAttribute('data-original-src', _normalizeLink(image.getAttribute('src')));
				// Use a tiny data-uri GIF as placeholder:
				image.setAttribute('src', 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==');
				// Add a placeholder class:
				$(image).addClass('cpr-placeholder');
			}
		}
		return content;
	};

	// Modify SVG images URL and put it in a new IMG element.
	var _parseSVG = function(content){
		var svg = content.getElementsByTagNameNS('http://www.w3.org/2000/svg', 'svg');

		if (svg.length === 0) { // Just in case the tags are not in the NS format
			svg = content.getElementsByTagName('svg');
		}
		if (svg) {
			for (var j = 0; j < svg.length; j++) {
				var img = svg[j].getElementsByTagNameNS('http://www.w3.org/2000/svg', 'image')[0];
				if (img === undefined) {
					// Check if the tag is IMG
					img = svg[j].getElementsByTagName('img')[0];
				}
				if (img === undefined) {
					// Check if the tag is IMAGE but it does not have Namespace
					img = svg[j].getElementsByTagName('image')[0];
				}
				if (img) {
					if (img.hasAttributeNS('http://www.w3.org/1999/xlink', 'href')) {
						var url = img.getAttributeNS('http://www.w3.org/1999/xlink', 'href');
            // Save original URL for the image:
            img.setAttribute('data-original-src', _normalizeLink(url));
						img.setAttributeNS('http://www.w3.org/1999/xlink', 'href',  _parseURL(url));
					}
				}
			}
		}
		return content;
	};

	// Modify video URL.
	var _parseVideos = function(content){
		var videos = content.getElementsByTagName('video');
		for (var y = 0; y < videos.length; y++) {
			var vidSrc = videos[y].getAttribute('src');
			vidSrc = _parseURL(vidSrc);
			videos[y].setAttribute('src', vidSrc);
		}
		return content;
	};


	// helper function that strips the last path from the url
	// Ex: a/b/c.html -> a/b
	var _removeLastPath = function(url){
		var pathSeparatorIndex = url.lastIndexOf('/');
		return pathSeparatorIndex !== -1 ? url.substring(0, pathSeparatorIndex) : '';
	};

	// Function to transform relative links
	// ex: `../html/chapter.html` -> `chapter.html`
	var _normalizeLink = function(url){
		// get current chapter folder url
		var chapter = r.Navigation.getChapter(), chapterURL = _removeLastPath(r.Book.spine[chapter].href), result = chapterURL;

		// parse current url to remove `..` from path
		var paths = url.split('/');
		for(var i = 0, l = paths.length; i < l; i++){
			var path = paths[i];
			if(path === '..'){
				result = _removeLastPath(result);
			} else {
				result += (!result ? '' : '/') + path;
			}
		}
		return result;
	};

	var _parseCSSLinks = function(content){
		var links = content.getElementsByTagName('link');
		for (var y = 0; y < links.length; y++) {
			var href = links[y].getAttribute('href');
			href = _parseURL(href);
			links[y].setAttribute('href', href);
		}
		return content;
	};

	var _appendHighlightOverlay = function(){
		r.$overlay = $('<div id="cpr-overlay" class="cpr-highlight"></div>').appendTo(r.$reader);
	};

	// Register all the anchors.
	filters.addFilter(HOOKS.BEFORE_CHAPTER_DISPLAY, _anchorData);
	filters.addFilter(HOOKS.BEFORE_CHAPTER_PARSE, _parseImages);
	filters.addFilter(HOOKS.BEFORE_CHAPTER_PARSE, _parseSVG);
	filters.addFilter(HOOKS.BEFORE_CHAPTER_PARSE, _parseVideos);
	filters.addFilter(HOOKS.BEFORE_CHAPTER_PARSE, _parseCSSLinks);
	filters.addFilter(HOOKS.AFTER_CHAPTER_DISPLAY, _appendHighlightOverlay);

	r.Filters = $.extend({HOOKS: HOOKS}, filters);

	return r;
}(Reader || {}));

'use strict';

/* jshint unused: true */
/* exported Reader */

// The **Formatting** options available to the user.
//
// * [`setLineHeight`](#setLineHeight)
// * [`increaseLineHeight`](#increaseLineHeight)
// * [`decreaseLineHeight`](#decreaseLineHeight)
// * [`setFontSize`](#setFontSize)
// * [`setTextAlign`](#setTextAlign)
// * [`setFontFamily`](#setFontFamily)
// * [`increaseFontSize`](#increaseFontSize)
// * [`decreaseFontSize`](#decreaseFontSize)
// * [`setMargin`](#setMargin)
// * [`setTheme`](#setTheme)

var Reader = (function (r) {
	// <a name="setLineHeight"></a>Set line size, if within bounds.
	// If current line height is larger than the minimum line height, decrease it by one unit.
	// Returns the current value of the line height
	r.setLineHeight = function(value){
		return r.setPreferences({lineHeight: value});
	};

	// <a name="increaseLineHeight"></a>Increase line size, if possible
	// If current line height is smaller than the maximum line height, increase it by one unit.
	// ReturnS the current value of the line height.
	r.increaseLineHeight = function(){
		return r.setPreferences({lineHeight: r.preferences.lineHeight.value + r.preferences.lineHeight.unit});
	};

	// <a name="decreaseLineHeight"></a>Decrease line size, if possible.
	// If current line height is larger than the minimum line height, decrease it by one unit.
	// Returns the current value of the line height.
	r.decreaseLineHeight = function(){
		return r.setPreferences({lineHeight: r.preferences.lineHeight.value - r.preferences.lineHeight.unit});
	};

	// <a name="setFontSize"></a>Set font size, if within bounds.
	// If current font size is larger than the minimum font, decrease it by one unit.
	// Returns the current value of the line height.
	r.setFontSize = function(value){
		return r.setPreferences({fontSize: value});
	};

	// <a name="setTextAlign"></a>Set the text alignment, acceptable values are only left or justified.
	// If the argument is different than the acceptable values, defaults to left.
	// Return the current value of the text align.
	r.setTextAlign = function(value){
		return r.setPreferences({textAlign: value});
	};

	// <a name="setFontFamily"></a>Set font family
	// Return the current font-family of the reader.
	r.setFontFamily = function(value){
		return r.setPreferences({fontFamily: value});
	};

	// <a name="increaseFontSize"></a>Increase font size, if possible.
	// If current font size is smaller than the maximum font size, increase it by one unit.
	// Returns the current value of the font size.
	r.increaseFontSize = function(){
		return r.setPreferences({fontSize: r.preferences.fontSize.value + r.preferences.fontSize.unit});
	};

	// <a name="decreaseFontSize"></a>Decrease font size, if possible
	// If current font size is larger than the minimum font size, decrease it by one unit
	// Returns the current value of the font size
	r.decreaseFontSize = function(){
		return r.setPreferences({fontSize: r.preferences.fontSize.value - r.preferences.fontSize.unit});
	};

	// <a name="setMargin"></a>Setter for the reader's margin property
	//
	// * `args` an array of 4 integers representing the top, right, bottom, left margins. Can also accept keyword params such as 'min', 'max' and 'medium'.
	// Returns the updated margins.
	r.setMargin = function(args){
		return r.setPreferences({margin:args});
	};

	// <a name="setTheme"></a>Setter for the reader's theme
	//
	// * `args` an object containing the color and background of the theme. Can also accept keyword params such as 'light', 'dark' and 'sepia'
	// Returns the current theme
	r.setTheme = function(args){
		return r.setPreferences({theme:args});
	};

	// <a name="setPreferences"></a>Set all style related user preferences
	//
	// * `args` an Object containing valid preference values.

	r.setPreferences = function (args) {
		if (typeof args !== 'object') {
			return r.preferences;
		}
		var updated = false,
				pref,
				value,
				prop;

		function refresh() {
			r.refreshLayout();
		}

		for (prop in args) {
			if (args.hasOwnProperty(prop)) {
				pref = r.preferences[prop];
				value = args[prop];
				switch (prop) {
					case 'lineHeight':
					case 'fontSize':
					case 'textAlign':
					case 'fontFamily':
					case 'theme':
						value = pref.clear(value);
						if (pref.value !== value) {
							pref.value = value;
							updated = true;
						}
						break;
					case 'transitionTimingFunction':
						pref.value = value;
						r.$reader.css('transition-timing-function', value);
						break;
					case 'publisherStyles':
						value = Boolean(value);
						if (value !== pref.value) {
							pref.value = value;
							if (value) {
								r.addPublisherStyles().then(refresh);
							} else {
								r.resetPublisherStyles();
								r.refreshLayout();
							}
						}
						break;
					case 'margin':
						value = pref.clear(value);
						if (value !== pref.value) {
							pref.value = value;
							r.Layout.resizeContainer();
							updated = true;
						}
						break;
					default:
						pref.value = pref.clear(value);
				}
			}
		}

		if (updated) {
			r.preferences.applyAll();
			// Update variables that are dependant on styles.
			r.refreshLayout();
		}
		return r.preferences;
	};

	return r;
}(Reader || {}));

'use strict';

var Reader = (function (r) {

	r.Layout = {
		Container: {
			width: 0,
			height: 0
		},
		Reader: {
			width: 0,
			height: 0,
			columns: 1,
			padding: 0
		},
		resizeContainer: function(dimensions){
			dimensions = $.extend({
				width: r.Layout.Container.width,
				height: r.Layout.Container.height,
				columns: r.Layout.Reader.columns,
				padding: r.Layout.Reader.padding
			}, dimensions);

			// Save new values.
			r.Layout.Container.width = Math.floor(dimensions.width);
			r.Layout.Container.height = Math.floor(dimensions.height);
			r.Layout.Reader.width = r.Layout.Container.width - Math.floor(r.preferences.margin.value[1]*r.Layout.Container.width/100) - Math.floor(r.preferences.margin.value[3]*r.Layout.Container.width/100);
			r.Layout.Reader.height = r.Layout.Container.height - Math.floor(r.preferences.margin.value[0]*r.Layout.Container.height/100) - Math.floor(r.preferences.margin.value[2]*r.Layout.Container.height/100);
			r.Layout.Reader.columns = dimensions.columns;
			r.Layout.Reader.padding = dimensions.padding;

			// avoid rounding errors, adjust the width of the reader to contain the columns + padding
			var columnWidth = Math.floor(r.Layout.Reader.width / r.Layout.Reader.columns - r.Layout.Reader.padding / 2),
					// columnAdjust adjusts the Reader padding depending on the column number and gap:
					columnAdjust = dimensions.columns > 1 ? 0 : Math.floor(r.Layout.Reader.padding / 4);
			r.Layout.Reader.width = columnWidth * r.Layout.Reader.columns + (r.Layout.Reader.columns - 1) * r.Layout.Reader.padding;

			// Apply new size
			r.$iframe.css({
				width: r.Layout.Container.width + 'px',
				height: r.Layout.Container.height + 'px'
			});

			r.$reader.css({
				// Position absolute fixes a layout issue on the Huddle:
				position: 'absolute',
				width: r.Layout.Reader.width + 'px',
				height: r.Layout.Reader.height + 'px',
				'column-width': columnWidth + 'px',
				'column-gap': r.Layout.Reader.padding + 'px',
				'column-fill': 'auto'
			});

			r.$container.css({
				// Position relative is required to set the reader to position absolute:
				position: 'relative',
				width: r.Layout.Reader.width + 'px',
				height: r.Layout.Reader.height + 'px',
				'margin-left': Math.floor(r.preferences.margin.value[3] * r.Layout.Container.width/100 + columnAdjust) + 'px',
				'margin-right': Math.floor(r.preferences.margin.value[1] * r.Layout.Container.width/100) + 'px'
			});

			r.$header.css({
				width: r.Layout.Reader.width + 'px',
				'margin-left': Math.floor(r.preferences.margin.value[3] * r.Layout.Container.width/100 + columnAdjust) + 'px',
				'margin-right': Math.floor(r.preferences.margin.value[1] * r.Layout.Container.width/100) + 'px',
				'height': Math.floor(r.preferences.margin.value[0] * r.Layout.Container.height/100) + 'px',
				'line-height': Math.floor(r.preferences.margin.value[0] * r.Layout.Container.height/100) + 'px'
			});

			r.$footer.css({
				width: r.Layout.Reader.width + 'px',
				'margin-left': Math.floor(r.preferences.margin.value[3] * r.Layout.Container.width/100 + columnAdjust) + 'px',
				'margin-right': Math.floor(r.preferences.margin.value[1] * r.Layout.Container.width/100) + 'px',
				'height': Math.floor(r.preferences.margin.value[2] * r.Layout.Container.height/100) + 'px',
				'line-height': Math.floor(r.preferences.margin.value[2] * r.Layout.Container.height/100) + 'px'
			});

			_resizeImages();
			// Update navigation variables
			r.refreshLayout();
		}
	};

	// Modifies some parameter related to the dimensions of the images and svg elements.
	var _resizeImages = function(){
		// Get SVG elements
		$('svg', r.$reader).each(function(index,node){
			// Calculate 95% of the width and height of the container.
			var width = Math.floor(0.95 * (r.Layout.Reader.width / r.Layout.Reader.columns - r.Layout.Reader.padding / 2));
			var height = Math.floor(0.95 * r.Layout.Reader.height);
			// Modify SVG params when the dimensions are higher than the view space or they are set in % as this unit is not working in IE.
			if ((node.getAttribute('width') && (node.getAttribute('width') > r.Layout.Reader.width || node.getAttribute('width').indexOf('%') !== -1)) || !node.getAttribute('width')) {
				node.setAttribute('width', width);
			}
			if ((node.getAttribute('height') && (node.getAttribute('height') > r.Layout.Reader.height || node.getAttribute('height').indexOf('%') !== -1)) || !node.getAttribute('height')) {
				node.setAttribute('height', height);
			}
			// Modify the viewBox attribute if their dimensions are higher than the container.
			node.viewBox.baseVal.width = (node.viewBox.baseVal.width > r.Layout.Reader.width) ? width : node.viewBox.baseVal.width;
			node.viewBox.baseVal.height = (node.viewBox.baseVal.height > r.Layout.Reader.height) ? height : node.viewBox.baseVal.height;
			node.setAttribute('transform', 'scale(1)');
			// Modify children elements (images, rectangles, circles..) dimensions if they are higher than the container.
			$(this).children().map(function(){
				if ($(this).attr('width') > r.Layout.Reader.width) {
					$(this).attr('width', width);
				}
				if ($(this).attr('height') > r.Layout.Reader.height) {
					$(this).attr('height', height);
				}
			});
			if ($(this).find('path')) {
				// Fix path elements dimensions.
				var pathMaxWidth = 0;
				var pathMaxHeight = 0;
				// Take the highest width and height.
				$(this).find('path').each(function(){
					var pathWidth = $(this)[0].getBoundingClientRect().width;
					var pathHeight = $(this)[0].getBoundingClientRect().height;
					pathMaxWidth = (pathWidth > pathMaxWidth) ? pathWidth : pathMaxWidth;
					pathMaxHeight = (pathHeight > pathMaxHeight) ? pathHeight : pathMaxHeight;
				});
				if (pathMaxWidth > width || pathMaxHeight > height) {
					// Scale the elements to the correct proportion.
					var scale = Math.min(Math.floor((width/pathMaxWidth)*10)/10,Math.floor((height/pathMaxHeight)*10)/10);
					$(this).find('path').each(function(){
						$(this)[0].setAttribute('transform', 'scale(' + scale + ')');
					});
				}
			}
			// Remove SVG empty elements in some Webkit browsers is showing the content outside the SVG (Chrome).
			if ($(this).children().length === 0) {
				$(this).remove();
			}
		});
	};

	return r;
}(Reader || {}));

'use strict';

/* jshint unused: true */
/* exported Reader */
/* global $ */

var Reader = (function (r) {

	r.Book.spine = [];

	// Number of chapters.
	var bookChapters = 0;
	// Initial chapter by default.
	var chapter = 0;
	// Initial page by default.
	var page = 0;
	// Number of pages in the actual chapter (columns number).
	var pagesByChapter = 0;
	// The current location's CFI.
	var _cfi = null;

	// A reference to the head node of the current chapter:
	var _chapterHead = $();
	// The chapter document file name:
	var chapterDocName = '';

	// Reset method for the reader.
	// *Note, some properties are not reset, such as preferences, listeners, styling*.
	r.reset = function(){
		r.DOCROOT = '';
		r.mobile = false;

		// Reset all modules.
		r.Epub.reset();
		r.Navigation.reset();
		r.Bookmarks.reset();
		r.Highlights.reset();
		r.Book.reset();

		// Remove book content.
		if(r.$parent){
			r.$parent.empty();
			r.$iframe = null;
			r.$wrap = null;
			r.$head = null;
			r.$container = null;
			r.$reader = null;
			r.$header = null;
			r.$footer = null;
			r.$stylesheet = null;
			r.$overlay = null;

			// reset link to CSS rules
			r.preferences.lineHeight.rules = [];
			r.preferences.fontSize.rules = [];
			r.preferences.fontFamily.rules = [];
			r.preferences.textAlign.rules = [];
			r.preferences.theme.rules = {
				background: [],
				title: [],
				color: []
			};
		}
	};

	r.getReaderOuterWidth = function () {
		return Math.floor(r.Layout.Reader.width + r.Layout.Reader.padding);
	};

	r.getReaderLeftPosition = function () {
		// Transform value is matrix(a, c, b, d, tx, ty)
		return parseInt(r.$reader.css('transform').split(',')[4], 10) || 0;
	};

	r.setReaderLeftPosition = function (pos, duration) {
		var defer = $.Deferred();
		// Force any previous transition to finish.
		// Calling the r.getReaderLeftPosition() getter also seems to be necessary
		// for the next transitionend event in some cases (e.g. the transition unit tests).
		r.$reader.css({
			'transition-duration': '0s',
			transform: 'translateX(' + r.getReaderLeftPosition() + 'px)'
		}).trigger(r.support.transitionend);
		if (duration) {
			r.$reader.one(r.support.transitionend, defer.resolve);
		} else {
			defer.resolve();
		}
		r.$reader.css({
			'transition-duration': (duration || 0) + 's',
			transform: 'translateX(' + pos + 'px)'
		});
		return defer.promise();
	};

	// Return the page number in the actual chapter where it is an element.
	r.moveToAnchor = function (id) {
		// Find the obj
		var obj = $(r.$iframe.contents()[0].getElementById(String(id)));
		if (obj.length === 0) {
			return 0; // If the object does not exist in the chapter we send the user to the page 0 of the chapter
		} else {
			// Check if the element has children and send the first one. This is to avoid the problems with big elements, like a wrapper for all the chapter.
			if (obj.children().length > 0) {
				return r.returnPageElement(obj.children().first());
			}
			return r.returnPageElement(obj);
		}
	};

	// Returns the page number related to an element.
	// [27.11.13] Refactored how we calculate the page for an element. Since the offset is calculated relative to the reader container now, we don't need to calculate the relative page number, only the absolute one.
	r.returnPageElement = function(obj) {
		obj = (obj instanceof $) ? obj : $(obj, r.$iframe.contents());
		if (!obj.length) {
			return -1;
		}
		var offset = obj.offset().left - r.$reader.offset().left;
		return Math.floor((offset) / r.getReaderOuterWidth());
	};

	var _getColumnsNumber = function() {
		var el = r.$reader[0];
		return Math.ceil(el.scrollWidth / r.getReaderOuterWidth());
	};

	// Refresh the content layout.
	r.refreshLayout = function(){
		// Update the number of columns
		pagesByChapter = _getColumnsNumber();
		var promise;
		// Maintain reader current position
		if(_cfi && _cfi.CFI) {
			promise = r.CFI.goToCFI(_cfi.CFI, true);
		} else {
			promise = $.Deferred().resolve().promise();
		}
		return promise.then(function () {
			r.Bookmarks.display();
			r.Highlights.display();
			r.Navigation.updateProgress();
		});
	};

	// The current book progress.
	var _progress = 0;

	// ## Navigation API
	// The Navigation object exposes methods to allow the user to navigate within the book.
	//
	// * `save`
	// * `setNumberOfChapters`
	// * `getPage`
	// * `setPage`
	// * `loadPage`
	// * `setNumberOfPagesInChapter`
	// * `setChapter`
	// * `getChapter`
	// * `getChapterDocName`
	// * `loadChapter`
	// * `next`
	// * `prev`
	// * `getCFI`
	// * `getCFIObject`
	// * `setCFI`
	// * `reset`
	// * `getProgress`
	// * `updateProgress`
	// * `getCurrentCFI`
	// * `updateCurrentCFI`
	// * `update`

	r.Navigation = {
		save: function(){
			/* for(var k in sLoad) { oLoad[k]=sLoad[k]; } */
		},
		setNumberOfChapters: function(numberOfChapters) {
			bookChapters = numberOfChapters;
		},
		getNumberOfChapters: function(){
			return Chapter.getTotal();
		},
		getPage: function() {
			return Page.get();
		},
		getPagePosition: function() {
			return -1 * r.getReaderOuterWidth() * Page.get();
		},
		getNumberOfPages: function(){
			return Page.getByChapter();
		},
		setNumberOfPages: function(){
			// Update the number of columns
			pagesByChapter = _getColumnsNumber();
		},
		setPage: function(p) {
			Page.set(p);
		},
		loadPage: function(p, fixed) {
			return Page.load(p, fixed);
		},
		setChapter: function(c){
			chapter = c;
			// Update the chapter doc name.
			try {
				var pathComponents = r.Book.spine[chapter].href.split('/');
				// get the last element in the array
				chapterDocName = pathComponents.slice(-1)[0];
			}
			catch (e) {
				console.log('setChapter:'+e);
			}
		},
		getChapter: function(){
			return Chapter.get();
		},
		setChapterHead: function (head) {
			_chapterHead = head;
		},
		getChapterHead: function () {
			return _chapterHead;
		},
		getChapterDocName: function() {
			return Chapter.getDocName();
		},
		loadChapter: function (anchorUrl) {
			var spine = r.Book.spine,
					urlParts = anchorUrl.split('#'),
					url = urlParts[0],
					anchor = urlParts[1],
					index;
			if (anchor && (!url || spine[chapter].href.indexOf(url) === 0) &&
				!r.Navigation.isChapterPartAnchor(anchor)) {
				// URL points to current chapter (and chapter part)
				return r.Navigation.loadPage(anchor);
			}
			index = r.Book.getSpineIndex(url);
			if (index !== -1) {
				return r.loadChapter(index, anchor);
			}
			return $.Deferred().reject(
					$.extend({}, r.Event.ERR_INVALID_ARGUMENT, {details: 'Specified chapter does not exist.', call: 'loadChapter', href: anchorUrl})
			).promise();
		},
		next: function() {
			if (page < pagesByChapter - 1) {
				return Page.next();
			}
			var defer = $.Deferred(),
					chapterPartUrl = r.Navigation.getNextChapterPartUrl(),
					loadPromise;
			if (chapterPartUrl || chapter < bookChapters - 1) {
				defer.notify({type: 'chapter.loading'});
				r.Book.preloadFile(chapterPartUrl || r.Book.spine[chapter + 1].href);
				Page.moveTo(
					page + 1,
					r.preferences.transitionDuration.value
				).then(function () {
					if (chapterPartUrl) {
						loadPromise = r.Navigation.loadChapter(chapterPartUrl);
					} else {
						loadPromise = Chapter.load(Chapter.next());
					}
					loadPromise.then(defer.resolve, defer.reject);
				});
			} else {
				defer.reject(r.Event.END_OF_BOOK);
			}
			return defer.promise();
		},
		prev: function() {
			if (page > 0) {
				return Page.prev();
			}
			var defer = $.Deferred(),
					chapterPartUrl = r.Navigation.getPrevChapterPartUrl(),
					loadPromise;
			if (chapterPartUrl || chapter > 0) {
				defer.notify({type: 'chapter.loading'});
				r.Book.preloadFile(chapterPartUrl || r.Book.spine[chapter - 1].href);
				Page.moveTo(
					page - 1,
					r.preferences.transitionDuration.value
				).then(function () {
					if (chapterPartUrl) {
						loadPromise = r.Navigation.loadChapter(chapterPartUrl);
					} else {
						loadPromise = Chapter.load(Chapter.prev(), r.Navigation.getLastPageAnchorName());
					}
					loadPromise.then(defer.resolve, defer.reject);
				});
			} else {
				defer.reject(r.Event.START_OF_BOOK);
			}
			return defer.promise();
		},
		reset: function(){
			bookChapters = 0;
			chapter = 0;
			page = 0;
			pagesByChapter = 0;
			_cfi = null;
			_progress = 0;
		},
		getProgress: function(){
			return _progress;
		},
		updateProgress: function () {
			var totalWordCount = r.Book.getTotalWordCount(),
					spineItem = r.Book.spine.length && r.Book.spine[chapter],
					// Get the current word count from the chapter progress
					// (which adds one word to the number of words of previous chapters):
					currentWordCount = spineItem ? Math.round(spineItem.progress / 100 * totalWordCount - 1) : 0;

			// Estimate read word count from current chapter:
			currentWordCount += spineItem ? r.Book.getWordCount(spineItem) * r.Navigation.getChapterReadFactor() : 0;

			// Calculate progress.
			var progress = currentWordCount / totalWordCount * 100;
			// If the progress has a valid value (is a number) AND it is different than the current one, update it and send an event notification.
			if (progress !== _progress && !isNaN(progress)) {
				_progress = progress;
				// Send notification to all listeners that the progress has been updated
				// r.execEvent(r.Event.PROGRESS_UPDATED);
			}

			if (r.mobile) {
				// Update footer and display progress.
				var progressContainer = $('#cpr-progress', r.$iframe.contents());
				if (!progressContainer.length) {
					progressContainer = $('<div id="cpr-progress"></div>').appendTo(r.$footer);
				}
				progressContainer.text(Math.floor(_progress) + (r.sample ? ' % of sample' : ' % read'));
			}
		},
		goToProgress: function (progress) {
			if ($.type(progress) !== 'number' || progress > 100 || progress < 0) {
				r.Notify.error($.extend({}, r.Event.ERR_INVALID_ARGUMENT, {details: 'Invalid progress', value: progress, call: 'goToProgress'}));
				return $.Deferred().reject().promise();
			}
			var targetWordCount = Math.ceil(progress / 100 * r.Book.getTotalWordCount()),
					wordCount = 0,
					progressFloat = 0,
					chapterWordCount,
					progressAnchor,
					i;
			for (i = 0; i < r.Book.spine.length; i++) {
				chapterWordCount = r.Book.getWordCount(r.Book.spine[i]);
				if (wordCount + chapterWordCount >= targetWordCount) {
					break;
				}
				wordCount += chapterWordCount;
			}
			if (chapterWordCount) {
				progressFloat = (targetWordCount - wordCount) / chapterWordCount;
			}
			progressAnchor = (progressFloat * 100) + '%';
			if (chapter !== i || !r.Navigation.isProgressInCurrentChapterPart(progressFloat)) {
				return r.loadChapter(i, progressAnchor);
			}
			return r.Navigation.loadPage(progressAnchor);
		},
		getCurrentCFI: function(){
			return _cfi;
		},
		updateCurrentCFI: function(){
			_cfi = r.CFI.getCFIObject();
		},
		update: function(){
			r.Navigation.updateCurrentCFI();
			r.Navigation.updateProgress();
			r.Bookmarks.display();
		},
		// Returns true for a progress anchor with a chapter percentage like e.g. "50%":
		isProgressAnchor: function (anchor) {
			return /%$/.test(anchor);
		},
		// Returns a floating point number from a percentage anchor, e.g. 0.5 for "50%":
		getProgressFromAnchor: function (anchor) {
			return Number(anchor.slice(0, -1)) / 100;
		},
		// Returns the page of the current chapter for the given percentage anchor:
		getProgressAnchorPage: function (anchor) {
			var progress = r.Navigation.getProgressFromAnchor(anchor),
					totalElements,
					readElements,
					partElements;
			if (r.Navigation.hasChapterParts()) {
				// Adjust the progress for the current chapter part:
				totalElements = r.Navigation.getNumberOfChapterPartsElements();
				readElements = r.Navigation.getCurrentChapterPart() * r.preferences.maxChapterElements.value;
				partElements = r.Navigation.getNumberOfChapterPartElements();
				progress = (progress * totalElements - readElements) / partElements;
			}
			return (Math.ceil(progress * pagesByChapter) || 1) - 1;
		},
		getLastPageAnchorName: function () {
			return 'cpr-lastpage';
		},
		isLastPageAnchor: function (anchor) {
			return /cpr-lastpage/.test(anchor);
		},
		getChapterPartAnchorPrefix: function () {
			return 'cpr-part';
		},
		isChapterPartAnchor: function (anchor) {
			return /^cpr-part/.test(anchor);
		},
		// Returns the number of removed elements from previous chapter parts:
		getPrevChapterPartMarker: function () {
			return r.$reader.find('#cpr-subchapter-prev');
		},
		// Returns the number of removed elements from previous chapter parts:
		getNextChapterPartMarker: function () {
			return r.$reader.find('#cpr-subchapter-next');
		},
		// Returns a collection of the available chapter part markers:
		getChapterPartMarkers: function () {
			return r.Navigation.getPrevChapterPartMarker().add(r.Navigation.getNextChapterPartMarker());
		},
		hasChapterParts: function () {
			return !!r.Navigation.getChapterPartMarkers().length;
		},
		// Returns the link to the next chapter part:
		getPrevChapterPartUrl: function () {
			return r.Navigation.getPrevChapterPartMarker().find('a').attr('href');
		},
		// Returns the link to the previous chapter part:
		getNextChapterPartUrl: function () {
			return r.Navigation.getNextChapterPartMarker().find('a').attr('href');
		},
		// Returns the zero based index of the current chapter part:
		getCurrentChapterPart: function () {
			return Number(r.Navigation.getChapterPartMarkers().attr('data-chapter-part')) || 0;
		},
		// Returns the number of parts the current chapter is split into:
		getNumberOfChapterParts: function () {
			return Number(r.Navigation.getChapterPartMarkers().attr('data-chapter-parts'));
		},
		// Returns the total number of elements counted for the chapter division calculation:
		getNumberOfChapterPartsElements: function () {
			return Number(r.Navigation.getChapterPartMarkers().attr('data-chapter-parts-elements'));
		},
		// Returns the number of elements counted for the current chapter part:
		getNumberOfChapterPartElements: function () {
			return Number(r.Navigation.getChapterPartMarkers().attr('data-chapter-part-elements')) || r.preferences.maxChapterElements.value;
		},
		// Returns true if the given floating point progress point is in the current chapter part:
		isProgressInCurrentChapterPart: function (progress) {
			return !r.Navigation.hasChapterParts() ||
				r.Navigation.getCurrentChapterPart() ===
					(Math.ceil(r.Navigation.getNumberOfChapterPartsElements() * progress / r.preferences.maxChapterElements.value) || 1) - 1;
		},
		// Returns the chapter part based on the given CFI:
		getChapterPartFromCFI: function (cfi) {
			var maxElements = r.preferences.maxChapterElements.value,
					part = 0;
			// Get the element path component of the cfi:
			// e.g. for epubcfi(/6/8!/4[body01]/2/402/2/1:0) get 4[body01]/2/402/2/1:0
			$.each((cfi.split('!')[1] || '').slice(1, -1).split('/'), function (key, value) {
				// Check if the CFI is found on a later chapter part by dividing the highest
				// branch count through the maxelements * 2 (CFI elements always have an even index):
				var newPart = Math.floor((parseInt(value, 10) - 1) / (maxElements * 2));
				if (newPart > 0) {
					part = newPart;
					// Break out of the $.each loop:
					return false;
				}
			});
			return part;
		},
		// Returns true if the given CFI can be found in the current chapter part:
		isCFIInCurrentChapterPart: function (cfi) {
			return !r.Navigation.hasChapterParts() || r.Navigation.getCurrentChapterPart() === r.Navigation.getChapterPartFromCFI(cfi);
		},
		// Calculate how much of the current chapter has been read:
		getChapterReadFactor: function () {
			var factor = (page + 1) / pagesByChapter,
					totalElements,
					readElements,
					partElements;
			if (r.Navigation.hasChapterParts()) {
				// Factor in the previous chapter parts, as pagesByChapter only counts the current chapter part:
				totalElements = r.Navigation.getNumberOfChapterPartsElements();
				readElements = r.Navigation.getCurrentChapterPart() * r.preferences.maxChapterElements.value;
				partElements = r.Navigation.getNumberOfChapterPartElements();
				return (readElements + partElements * factor) / totalElements;
			}
			return factor;
		}
	};

	// Returns images in the ideal loading order:
	function getImagesToLoad(reverse, nearestSelector) {
		// nearestSelector is the selector for the element identifying the current position,
		// e.g. a CFI marker as data attribute selector or an element id to identify an anchor in the current document:
		var nearestElement = nearestSelector && $(nearestSelector, r.$reader)[0],
				imgSelector = 'img.cpr-placeholder',
				// Both jQuery and the DOM selector API will return matching elements in DOM order.
				// Using this information, we combine the img selector with the nearestSelector:
				selector = nearestElement ? imgSelector + ',' + nearestSelector : imgSelector,
				// As a result, we will get a collection of elements with the CFI marker or anchor in the middle:
				images = $(selector, r.$reader),
				sortedImages,
				nearestIndex,
				i,
				el;
		// If the reverse argument is set, reverse the order of the elements,
		// which is useful for navigating backwards in a book:
		if (images.length > 1 && reverse) {
			images = $(images.get().reverse());
		}
		// If no position element is given, simply return the collected images:
		if (!nearestElement) {
			return images;
		}
		// Retrieve the index of the position element in the collection:
		nearestIndex = images.index(nearestElement);
		sortedImages = [];
		// Add the position element itself if it's matching the img selector:
		if ($(nearestElement).is(imgSelector)) {
			sortedImages.push(nearestElement);
		}
		// Add to the new collection starting with the images closest to the position element index:
		for (i = 1; sortedImages.length < images.length - 1; i++) {
			// Add the previous image before the position element:
			el = images[nearestIndex - i];
			if (el) {
				sortedImages.push(el);
			}
			// Add the next image after the position element:
			el = images[nearestIndex + i];
			if (el) {
				sortedImages.push(el);
			}
		}
		// Return the collection of img elements sorted based on their relative distance to the given element:
		return $(sortedImages);
	}

	// Loads images in sequential order based on the current chapter position:
	function loadImages(reverse, nearestSelector) {
		// A list to collect the images to be loaded:
		var updatedImages = $(),
				// Main deferred object, will be resolved once all the required images have been loaded:
				mainDefer = $.Deferred(),
				// Promise which will be used to chain the sequential image loading:
				promise = $.Deferred().resolve().promise();
		getImagesToLoad(reverse, nearestSelector).each(function () {
			var el = this,
					dataSrc = el && el.getAttribute('data-src');
			// Ignore images that have no data-src (safeguard, they should not be in the collection):
			if (!dataSrc) {
				return;
			}
			// Chaining the promises so we only load images until the nearest pages are filled.
			// Since each loaded image can influence the page layout we have to load them sequentially:
			promise = promise.then(function () {
				// Check if the img element is within the preload range:
				if (Math.abs(r.returnPageElement(el) - r.Navigation.getPage()) <= r.preferences.preloadRange.value) {
					var $el = $(el),
							defer = $.Deferred();
					$el.one('load', function () {
						// Remove all event handlers (load/error):
						$el.off();
						// Remove the placeholder class from the image element:
						$el.removeClass('cpr-placeholder');
						// All images greater than 75% of the reader width or height will receive cpr-img-large class to center them:
						var columnWidth = r.Layout.Reader.width / r.Layout.Reader.columns - r.Layout.Reader.padding / 2,
								columnHeight = r.Layout.Reader.height;
						if (el.width > 3/4 * columnWidth || el.height > 3/4 * columnHeight) {
							$el.addClass('cpr-img-large');
						} else  if(el.width > 1/4 * columnWidth || el.height > 1/4 * columnHeight){
							$el.addClass('cpr-img-medium');
						} else {
							$el.addClass('cpr-img-small');
						}
						// Notify on each image load:
						mainDefer.notify({type: 'img.load', element: el});
						updatedImages = updatedImages.add(el);
						// Resolve the promise for the current image:
						defer.resolve();
					});
					$el.one('error', function () {
						// Remove all event handlers (load/error):
						$el.off();
						// Restore the data-src to allow reloading the failed image:
						el.setAttribute('data-src', el.getAttribute('src'));
						// Restore the original src with the placeholder image:
						el.setAttribute('src', 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==');
						// Resolve the promise for the current image:
						defer.resolve();
					});
					// Notify on each image loading start:
					mainDefer.notify({type: 'img.loading', element: el});
					// Start the image load by using the data-src for the actual img src:
					el.setAttribute('src', dataSrc);
					// Remove the obsolete data-src:
					el.removeAttribute('data-src');
					return defer.promise();
				}
			});
		});
		// This method is called after all the required images have been loaded:
		function resolveLoadImages() {
			r.Filters.removeFilter(afterChapterDisplayFilter);
			mainDefer.resolve(updatedImages);
		}
		// When a new chapter is displayed, it will remove the current images on the page
		// and might prevent any outstanding img load events and never resolve loadImages.
		// Therefore we call resolveLoadImages manually after the chapter content has been replaced:
		function afterChapterDisplayFilter (content) {
			resolveLoadImages();
			return content;
		}
		r.Filters.addFilter(r.Filters.HOOKS.AFTER_CHAPTER_DISPLAY, afterChapterDisplayFilter);
		promise.then(resolveLoadImages);
		return mainDefer.promise();
	}

	// ## Page API
	// Actual page is contained in the variable _pageIndex.
	//
	// * `get` returns the index of the actual page.
	// * `getByChapter` return the total number of pages in the actual chapter.
	// * `next` refreshes the page variable adding one and moves to the next page (column)
	// * `prev` refreshes the page variable subtracting one and moves to the prev pave (column)
	// * `load` refreshes the page variable with a value and moves the scroll to its position
	var Page = {
		set: function(p) {
			page = p;
		},
		get: function() {
			return page;
		},
		getByChapter: function() {
			return pagesByChapter;
		},
		// Moves to the page given as index, epubcfi, anchor or special last page anchor:
		moveTo: function (p, duration) {
			if ($.type(p) === 'string') {
				if (r.Navigation.isLastPageAnchor(p)) {
					// jump to the last page of the chapter:
					page = pagesByChapter - 1;
				} else if (r.Navigation.isProgressAnchor(p)) {
					// page is given as chapter progress, jump to the equivalent part:
					page = r.Navigation.getProgressAnchorPage(p);
				} else if (r.CFI.isValidCFI(p)) {
					// page is given as CFI, jump to the page containing the CFI marker:
					var pos = r.CFI.findCFIElement(p);
					page = pos === -1 ? 0 : pos;
				} else {
					// page is given as element id, jump to the page containing the element:
					page = r.moveToAnchor(p);
				}
			} else {
				page = p || 0;
			}
			return r.setReaderLeftPosition(-1 * r.getReaderOuterWidth() * page, duration);
		},
		next: function() {
			return Page.moveTo(
				page + 1,
				r.preferences.transitionDuration.value
			).then(function () {
				r.Navigation.updateCurrentCFI();
				return loadImages().then(function (updatedImages) {
					if (updatedImages.length) {
						r.refreshLayout();
					} else {
						r.Navigation.updateProgress();
						r.Bookmarks.display();
					}
				});
			});
		},
		prev: function() {
			return Page.moveTo(
				page - 1,
				r.preferences.transitionDuration.value
			).then(function () {
				var imgLoad;
				r.Navigation.updateCurrentCFI();
				return loadImages(true)
					.progress(function (data) {
						if (!imgLoad && data.type === 'img.loading') {
							r.setReaderOpacity(0);
							imgLoad = true;
						} else if (data.type === 'img.load') {
							pagesByChapter = _getColumnsNumber();
							r.CFI.goToCFI(_cfi.CFI, true);
						}
					})
					.then(function () {
						r.Navigation.updateProgress();
						r.Bookmarks.display();
						r.Highlights.display();
						if (imgLoad) {
							r.setReaderOpacity(1);
						}
					});
			});
		},
		load: function(p, fixed) {
			var isString = $.type(p) === 'string',
				isLastPage,
				isProgressAnchor,
				selector,
				cfi;
			if (isString) {
				isLastPage = r.Navigation.isLastPageAnchor(p);
				isProgressAnchor = !isLastPage && r.Navigation.isProgressAnchor(p);
				if (!isLastPage && !isProgressAnchor) {
					if (r.CFI.isValidCFI(p)) {
						selector = r.CFI.getCFISelector(p);
					} else {
						selector = p;
					}
				}
			}
			Page.moveTo(p);
			if (isProgressAnchor) {
				// If we have a progress anchor, load images based around the new position:
				cfi = r.CFI.getCFIObject();
				selector = cfi && r.CFI.getCFISelector(cfi.CFI);
			}
			var promise = loadImages(isLastPage, selector)
				.progress(function () {
					// Update the colums and page position on each image load:
					pagesByChapter = _getColumnsNumber();
					Page.moveTo(p);
				});
			if (!fixed) {
				promise = promise.then(function () {
					r.Navigation.update();
				});
			}
			return promise;
		}
	};

	// ## Chapter API
	// Chapters number is contained in the variable _bookChapters.
	// Chapter index is controlled with the _bookChapter variable.
	//
	// * `get` returns the index of the actual chapter (_bookChapter)
	// * `getTotal` returns the total number of pages in the actual chapter.
	// * `next` refresh the index variable adding one.
	// * `prev` refresh the index variable subtracting one.
	var Chapter = {
		get: function(callback) {
			if (callback && typeof(callback) === 'function') { callback(); }
			return chapter;
		},
		getDocName: function(callback) {
			if (callback && typeof(callback) === 'function') { callback(); }
			return chapterDocName;
		},
		getTotal: function(callback) {
			if (callback && typeof(callback) === 'function') { callback(); }
			return bookChapters;
		},
		next: function() {
			return ++chapter;
		},
		prev: function() {
			return --chapter;
		},
		load: function(c, p) {
			return r.loadChapter(c, p);
		}
	};

	return r;

}(Reader || {}));

/**
 * ReaderJS v1.0.0
 * (c) 2013 BlinkboxBooks
 * parse.js: methods to parse and clean the content
 */

'use strict';

var Reader = (function (r) {

	// Parses the content according its mimetype. Returns the parsed content
	//
	// * `content` The content of the document
	// * `mimetype` The MIME type of the given document
	// * `options` addtional options containing the url of the file and the page to load
	r.parse = function (content, mimetype, options) {

		if(typeof content !== 'string'){
			return null;
		}

		switch (mimetype) {
		case 'application/xhtml+xml':
			content = parseXHTML(content, options);
			break;
		default:
			break;
		}

		var head = content.split(/<head[^>]*>/)[1].split('</head>')[0],
			body = content.split(/<body[^>]*>/)[1].split('</body>')[0];

		// Extract the contents of the body only thus ignoring any styles declared in head
		return {
			$head: $(head),
			$body: $(body)
		};
	};

	// Function to divide large chapters with many repeating elements into several parts:
	function chapterDivide(doc, options) {
		options = options || {};
		var page = options.page,
				// Only use the basename without anchor for the url:
				url = options.url.split('/').slice(-1)[0].split('#')[0],
				maxElements = r.preferences.maxChapterElements.value,
				// Find the parent element of the repeating elements which exceed the max chapter elements:
				parent = $(doc).find(':nth-child(0n+' + (maxElements + 1) + ')').first().parent(),
				children,
				parts,
				part,
				prefix,
				lastPageSuffix,
				nodeName,
				index;
		if (parent.length) {
			children = parent.children();
			// The number of parts to split this chapter into:
			parts = Math.ceil(children.length / maxElements);
			// By default, start with the first part (zero-indexed):
			part = 0;
			// The prefix to identify anchors to chapter parts:
			prefix = r.Navigation.getChapterPartAnchorPrefix() + '-';
			// The suffix to identify last page positions:
			lastPageSuffix = '-' + r.Navigation.getLastPageAnchorName();
			// The nodeName of the next/prev link-wrapper, a div unless the parent is a list:
			nodeName = /^(ul|ol)$/i.test(parent.prop('nodeName')) ? 'li' : 'div';
			if (r.Navigation.isChapterPartAnchor(page)) {
				// Get the current part from the page anchor:
				part = Number(String(page).replace(prefix, '').replace(lastPageSuffix, '')) || 0;
			} else if (r.Navigation.isLastPageAnchor(page)) {
				// Anchor points to the last page in the chapter, so select the last part:
				part = parts - 1;
			} else if (r.Navigation.isProgressAnchor(page)) {
				// Anchor points to chapter progress, jump to the equivalent part:
				part = (Math.ceil(children.length * r.Navigation.getProgressFromAnchor(page) / maxElements) || 1) - 1;
			} else if (r.CFI.isValidCFI(page)) {
				part = r.Navigation.getChapterPartFromCFI(page);
			} else if ($.type(page) === 'string') {
				// Handle page anchors:
				index = $(doc).find('#' + page).closest(children).index();
				if (index >= maxElements) {
					part = Math.floor(index / maxElements);
				}
			}
			// Remove all elements up to the current part:
			children.slice(0, maxElements * part).remove();
			// Remove all elements after current part:
			children.slice(maxElements * (part + 1)).remove();
			if (part) {
				// Add a link to the previous part:
				$(document.createElement(nodeName))
					.prop('id', 'cpr-subchapter-prev')
					.addClass('cpr-subchapter-link')
					.append($('<a></a>').prop('href', url + '#' + prefix + (part - 1) + lastPageSuffix))
					.attr('data-chapter-part', part)
					// Add the number of remaining elements for the last chapter part:
					.attr('data-chapter-part-elements', part < parts - 1 ? undefined : children.length - part * maxElements)
					.attr('data-chapter-parts', parts)
					.attr('data-chapter-parts-elements', children.length)
					.prependTo(parent);
			}
			if (part < parts - 1) {
				// Add a link to the next part:
				$(document.createElement(nodeName))
					.prop('id', 'cpr-subchapter-next')
					.addClass('cpr-subchapter-link')
					.append($('<a></a>').prop('href', url + '#' + prefix + (part + 1)))
					// Add the number of parts and elements if they're not already added to the prev node:
					.attr('data-chapter-parts', part ? undefined : parts)
					.attr('data-chapter-parts-elements', part ? undefined : children.length)
					.appendTo(parent);
			}
		}
	}

	// Parses the content in application/xhtml+xml. Returns the parsed content.
	//
	// * `content` The content of the document
	// * `options` addtional options containing the url of the file and the page to load
	var parseXHTML = function (content, options) {
		var parser = new DOMParser();
		if (content.indexOf('<!-- livereload snippet -->') !== -1) {
			// Delete livereload script tags (added by grunt to html files)
			content = content.split('<!-- livereload snippet -->')[0].trim() + '</body></html>';
		}

		var object = parser.parseFromString(content, 'application/xhtml+xml');
		if(object.getElementsByTagName('parsererror').length > 0){
			// TODO Refactor
			// Parsing failures should be handled differently than just sending an error to the client
			r.Notify.error(r.Event.ERR_PARSING_FAILED);
		}

		object = r.Filters.applyFilters(r.Filters.HOOKS.BEFORE_CHAPTER_PARSE, object);

		var prefixes = [];
		// Get all elements in any namespace.
		var elements = object.getElementsByTagNameNS('*', '*');

		if (elements.length > r.preferences.maxChapterElements.value) {
			// divide large chapters into subchapters:
			chapterDivide(object, options);
		}

		var html = '<!DOCTYPE html>\n<html>' + object.documentElement.innerHTML + '</html>';
		// Remove the prefix in those that have.
		for (var k = 0; k < elements.length; k++) {
			if (elements[k].prefix) {
				prefixes[elements[k].prefix] = {prefix: elements[k].prefix, uri: elements[k].namespaceURI};
			}
		}

		// Search all prefixes in the code and remove them, also search the declaration of this prefix and also eliminates them.
		for (var x in prefixes) {
			var prefix = prefixes[x].prefix;
			var uri = prefixes[x].uri;
			// Patterns to search the prefixes and their namespace declarations.
			var pattern_open = new RegExp('<' + prefix + ':', 'g');
			var pattern_close = new RegExp('<\/' + prefix + ':', 'g');
			var namespaceURI = new RegExp('xmlns:' + prefix + '=\"' + uri + '\"', 'g');

			html = html.replace(pattern_open, '<');
			html = html.replace(pattern_close, '</');
			html = html.replace(namespaceURI, '');
		}
		return html;
	};

	return r;

}(Reader || {}));
'use strict';

/* jshint unused: true */
/* exported Reader */

var Reader = (function (r) {

	// based on http://websemantics.co.uk/resources/font_size_conversion_chart/
	var _fontSizes = {
		'x-small': 0.555, // 10px
		'small': 0.7222, // 13px
		'medium': 0.89, // 16 px
		'large': 1, // 18 px
		'x-large': 1.333, // 24px
		'xx-large': 1.777, // 32px
		'smaller': 'smaller',
		'larger': 'larger'
	};

	/*
	 * Will convert a font size css declaration to rems
	 * */
	function _parseFontSize(size) {
		if(size.indexOf('px') !== -1){
			return parseFloat(size) / 18;
		} else if(size.indexOf('small') !== -1 || size.indexOf('large') !== -1){
			return _fontSizes[size] || '';
		} else if(size.indexOf('em') !== -1){
			return parseFloat(size);
		} else {
			// if font-size unit is not recognised, return default
			return 1;
		}
	}

	// Will set a maximum size of 0.5 of a column width for the given size
	// result is always in px
	function _parseSize(size) {
		var columnWidth = Math.floor(r.Layout.Reader.width / r.Layout.Reader.columns - r.Layout.Reader.padding / 2),
			value = 0;

		if(size.indexOf('px') !== -1){
			value = Math.min(parseFloat(size), columnWidth / 2);
		} else if(size.indexOf('em') !== -1){
			value = Math.min(parseFloat(size) * 18, columnWidth / 2);
		} else if(size.indexOf('%') !== -1){
			// do not allow relative margins higher than 100
			value = Math.min(parseFloat(size), 100) * columnWidth / 100;
		}

		// if size unit is not recognised, return 0
		// we cannot allow negative margins, paddings and text indents.
		// Some books rely on the body having a left margin to display property, but the body is used for layout and cannot have any margins on it http://jira.blinkbox.local/jira/browse/CR-331
		return Math.max(value, 0);
	}

	function _parseCSS(style) {
		var doc = document.implementation.createHTMLDocument(''),
			styleElement = document.createElement('style');

		styleElement.textContent = style;

		// the style will only be parsed once it is added to a document
		doc.body.appendChild(styleElement);

		return styleElement.sheet;
	}

	r.resetPublisherStyles = function () {
		if (r.$stylesheet) {
			// Reset the existing publisher styles:
			r.$stylesheet = $('<style></style>').replaceAll(r.$stylesheet);
		} else {
			// Append a placeholder for the publisher styles:
			r.$stylesheet = $('<style></style>').appendTo(r.$head);
		}
		return r.$stylesheet;
	};

	r.addPublisherStyles = function () {
		var links = [];
		r.Navigation.getChapterHead().filter('link[href$=".css"]').each(function (index, link) {
			links.push($.ajax({
				url: link.href
			}));
		});
		return $.when.apply($, links).then(function () {
			var i, l, j, k;

			// remove previous styles
			r.resetPublisherStyles();

			// append whitelisted properties
			var sheet = r.$stylesheet[0].sheet,
				whitelist = {
					textAlign: 'text-align',
					fontStyle: 'font-style',
					fontWeight: 'font-weight',
					fontSize: 'font-size',
					textDecoration: 'text-decoration',
					textIndent: 'text-indent',
					textTransform: 'text-transform',
					marginLeft: 'margin-left',
					marginTop: 'margin-top',
					marginRight: 'margin-right',
					marginBottom: 'margin-bottom',
					paddingLeft: 'padding-left',
					paddingTop: 'padding-top',
					paddingRight: 'padding-right',
					paddingBottom: 'padding-bottom',
					display: 'display',
					borderLeftWidth: 'border-left-width',
					borderRightWidth: 'border-right-width',
					borderTopWidth: 'border-top-width',
					borderBottomWidth: 'border-bottom-width',
					borderLeftStyle: 'border-left-style',
					borderRightStyle: 'border-right-style',
					borderTopStyle: 'border-top-style',
					borderBottomStyle: 'border-bottom-style',
					borderLeftColor: 'border-left-color',
					borderRightColor: 'border-right-color',
					borderTopColor: 'border-top-color',
					borderBottomColor: 'border-bottom-color',
					float: 'float'
				};
			for (i = 0, l = links.length; i < l; i++) {
				var rules = _parseCSS(arguments[i]).cssRules;
				for (j = 0, k = rules.length; j < k; j++) {
					var rule = rules[j];
					if (rule.style) {
						var cssText = '';
						for (var key in whitelist) {
							if (rule.style[key]) {
								// convert px font-size to rem, todo: convert other sizes?
								if (key === 'fontSize') {
									cssText += ';' + whitelist[key] + ':' + _parseFontSize(rule.style[key]) + 'rem';
								} else if (key.indexOf('margin') !== -1 || key.indexOf('padding') !== -1 || key === 'textIndent') {
									cssText += ';' + whitelist[key] + ':' + _parseSize(rule.style[key]) + 'px';
								} else {
									cssText += ';' + whitelist[key] + ':' + rule.style[key];
								}
							}
						}
						if (cssText && rule.selectorText && rule.selectorText.indexOf('html') === -1 && rule.selectorText.indexOf('body') === -1) {
							sheet.insertRule(rule.selectorText + '{' + cssText + '}', sheet.cssRules.length);
						}
					}
				}
			}
		});
	};

	r.hideHeaderAndFooter = function(){
		r.$header.css({visibility: 'hidden'});
		r.$footer.css({visibility: 'hidden'});
	};

	r.showHeaderAndFooter = function(){
		r.$header.css({visibility: 'visible'});
		r.$footer.css({visibility: 'visible'});
	};

	r.setReaderOpacity = function (opacity, duration) {
		var defer = $.Deferred();
		if (duration) {
			r.$reader.one(r.support.transitionend, defer.resolve);
		} else {
			defer.resolve();
		}
		r.$reader.css({
			'transition-duration': (duration || 0) + 's',
			opacity: opacity
		});
		return defer.promise();
	};

	return r;
}(Reader || {}));

/**
 * ReaderJS v1.0.0
 * (c) 2013 BlinkboxBooks
 * touch.js: touch handling for the Reader
 *
 * Touch movement code based on
 * https://github.com/blueimp/Gallery
 */

/* exported Reader */

var Reader = (function (r) {
	'use strict';

	var touchStartData,
			touchDelta,
			isVerticalScroll,
			leftPosition,
      waitingTap = false,
      navInterface,
      touchTimeout;

	function resetPosition() {
		// Move back to the original position:
		r.setReaderLeftPosition(leftPosition, r.preferences.transitionDuration.value);
	}

  function sendUnhandledTouchEvent(touchStartData) {
    waitingTap = false;
    r.Notify.event($.extend({}, r.Event.UNHANDLED_TOUCH_EVENT, touchStartData));
  }

	r.Touch = {
		reset: function () {
			touchStartData = undefined;
			touchDelta = undefined;
			isVerticalScroll = undefined;
		},
		start: function (e) {
			var touches = e.originalEvent.touches;
			touchStartData = {
				clientX: touches ? touches[0].clientX : null,
				clientY: touches ? touches[0].clientY : null,
				time: Date.now()
			};
			leftPosition = r.Navigation.getPagePosition();
		},
		move: function (e) {
			var touches = e.originalEvent.touches[0],
					scale = e.originalEvent.scale;
			// Ensure this is a one touch swipe and not, e.g. a pinch:
			if (touches.length > 1 || scale && scale !== 1) {
				return;
			}
			touchDelta = {
				x: touches.clientX - touchStartData.clientX,
				y: touches.clientY - touchStartData.clientY
			};
			// Detect if this is a vertical scroll movement (run only once per touch):
			if (isVerticalScroll === undefined) {
				isVerticalScroll = Math.abs(touchDelta.x) < Math.abs(touchDelta.y);
			}
			if (isVerticalScroll) {
				return;
			}
			// Always prevent horizontal scroll:
			e.preventDefault();
			r.setReaderLeftPosition(leftPosition + touchDelta.x);
		},
		end: function (e) {
			var isShortDuration = Date.now() - touchStartData.time < 250,
					promise,
          touchStartDataCopy;
			// Check if the swipe is a short flick or a swipe across more than half of the Reader:
			if (touchDelta && (isShortDuration && Math.abs(touchDelta.x) > 20 ||
					Math.abs(touchDelta.x) > r.Layout.Reader.width / 2)) {
				// Move the Reader page in the swipe direction:
				if (touchDelta.x < 0) {
					promise = navInterface.next();
				} else {
					promise = navInterface.prev();
				}
				// If we are already at the start or end of the book, reset to the last position:
				promise.fail(resetPosition);
			} else {
				if (touchDelta && !isVerticalScroll) {
					resetPosition();
				}
				if (isShortDuration && !$(e.target).closest('a').length && !waitingTap) {
          if ($(e.target).is('img') || $(e.target).is('image') || $(e.target).is('svg')) {
            waitingTap = true;
            touchStartDataCopy = touchStartData;
            touchTimeout = setTimeout(function () {
              sendUnhandledTouchEvent(touchStartDataCopy);
            }, r.preferences.doubleTapDelay.value);
          } else {
            sendUnhandledTouchEvent(touchStartData);
          }
				} else if (($(e.target).is('img') || $(e.target).is('image') || $(e.target).is('svg')) && waitingTap) {
          clearTimeout(touchTimeout);
          waitingTap = false;
          r.Notify.event($.extend({}, Reader.Event.IMAGE_SELECTION_EVENT, {
            src: $(e.target).attr('data-original-src')
          }));
        }
			}
			this.reset();
		},
		cancel: function (e) {
			this.end(e);
		},
		init: function (doc) {
			doc.on('touchstart touchmove touchend touchcancel', function (event) {
				r.Touch[event.type.slice(5)].call(r.Touch, event);
			});
			/**
			 * We need to use the wrapper's next/prev methods, to handle any possible event generation and keeping things DRY.
			 * */
			navInterface = READER || r.Navigation;
		}
	};

	return r;
}(Reader || {}));

'use strict';
/* exported READER */
/* globals $, Reader */
var READER = (function() {
	// Public methods from the Reader.
	// All client communication is done here and only here. Do NOT send any events from other files.
	// The reader should return a promise for any action, a promise that gets resolved/rejected and the appropriate event is fired when the promise is fulfiled.
	// The goal is to make the reader as client-ignorant as possible.

	var _isLoading = false;

	// Generates an object summarizing the reader status.
	function sendStatus(call) {
		Reader.Notify.event($.extend({}, Reader.Event.getStatus(call)));
	}

	// Wrap a reader action so that it will return the reader status after the action is performed
	function statusWrap(obj, method) {
		return function() {
			var result = obj[method].apply(obj, arguments);
			sendStatus(method);
			return result;
		};
	}

	// Wrap a reader action so that it will send loading notifications if applicable:
	function loadingWrap(obj, method) {
		return function() {
			if (_isLoading) {
				return $.Deferred().reject().promise();
			}
			return obj[method].apply(obj, arguments).always(function complete() {
				if (_isLoading) {
					Reader.Notify.event(Reader.Event.LOADING_COMPLETE);
					_isLoading = false;
				}
			}).then(
				function done() {
					sendStatus(method);
				},
				function fail(err) {
					if (err === Reader.Event.END_OF_BOOK || err === Reader.Event.START_OF_BOOK) {
						Reader.Notify.event(err);
					} else {
						Reader.Notify.error(err);
					}
				},
				function progress(args) {
					if (!_isLoading && args && (args.type === 'chapter.loading' || args.type === 'meta.loading')) {
						Reader.Notify.event(Reader.Event.LOADING_STARTED);
						_isLoading = true;
					}
				}
			);
		};
	}

	return {
		init: loadingWrap(Reader, 'init'),
		setLineHeight: statusWrap(Reader, 'setLineHeight'),
		increaseLineHeight: statusWrap(Reader, 'increaseLineHeight'),
		decreaseLineHeight: statusWrap(Reader, 'decreaseLineHeight'),
		increaseFontSize: statusWrap(Reader, 'increaseFontSize'),
		decreaseFontSize: statusWrap(Reader, 'decreaseFontSize'),
		setFontSize: statusWrap(Reader, 'setFontSize'),
		setTextAlign: statusWrap(Reader, 'setTextAlign'),
		setMargin: statusWrap(Reader, 'setMargin'),
		setTheme: statusWrap(Reader, 'setTheme'),
		setFontFamily: statusWrap(Reader, 'setFontFamily'),
		setPreferences: statusWrap(Reader, 'setPreferences'),
		getCFI: Reader.CFI.getCFI,
		goToCFI: loadingWrap(Reader.CFI, 'goToCFI'),
		goToProgress: loadingWrap(Reader.Navigation, 'goToProgress'),
		next: loadingWrap(Reader.Navigation, 'next'),
		prev: loadingWrap(Reader.Navigation, 'prev'),
		loadChapter: loadingWrap(Reader.Navigation, 'loadChapter'),
		getProgress: Reader.Navigation.getProgress,
		getBookmarks: Reader.Bookmarks.getBookmarks,
		setBookmarks: statusWrap(Reader.Bookmarks, 'setBookmarks'),
		setBookmark: statusWrap(Reader.Bookmarks, 'setBookmark'),
		goToBookmark: loadingWrap(Reader.Bookmarks, 'goToBookmark'),
		removeBookmark: statusWrap(Reader.Bookmarks, 'removeBookmark'),
		setHighlight: statusWrap(Reader.Highlights, 'setHighlight'),
		setHighlights: statusWrap(Reader.Highlights, 'setHighlights'),
		removeHighlight: statusWrap(Reader.Highlights, 'removeHighlight'),
		showHeaderAndFooter: Reader.showHeaderAndFooter,
		hideHeaderAndFooter: Reader.hideHeaderAndFooter,
		resizeContainer: statusWrap(Reader.Layout, 'resizeContainer'),
		Event: Reader.Event,
		refreshLayout: statusWrap(Reader, 'refreshLayout'),
		enableDebug: Reader.Debug.enable,
		disableDebug: Reader.Debug.disable
	};
}());
